# app/services/content/generator.py
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, Dict, Any, List, Union
import logging
import json
import datetime
from datetime import datetime, timedelta
import asyncio
import time
import re
import hashlib
import os
import random
import traceback
logger = logging.getLogger(__name__)


class ContentGenerator:
    def __init__(self, session: AsyncSession):
        self.session = session
        self.query_optimizer = QueryOptimizer(session)
        self.cache_service = CacheService()
        self.batch_processor = BatchProcessor(session)
        # Initialize queue to None - we'll create it when needed
        self._generation_queue = None

        # Получаем API ключи из переменных окружения
        mistral_api_key = os.environ.get("MISTRAL_API_KEY")
        gemini_api_key = os.environ.get("GEMINI_API_KEY")

        # Инициализируем обработчики API для разных провайдеров
        self.mistral_handler = None
        self.gemini_handler = None
        self.g4f_handler = None

        # Флаги доступности провайдеров
        self._mistral_available = False
        self._gemini_available = False
        self._g4f_available = False

        # Инициализируем Gemini API если доступен ключ
        if gemini_api_key:
            try:
                from ...utils.gemini_api import GeminiHandler, GEMINI_AVAILABLE
                if GEMINI_AVAILABLE:
                    self.gemini_handler = GeminiHandler(api_key=gemini_api_key)
                    self._gemini_available = self.gemini_handler.is_available()
                    logger.info(f"GeminiHandler инициализирован и доступен: {self._gemini_available}")
                else:
                    logger.warning(
                        "Библиотека Google Generative AI не установлена")
            except Exception as e:
                logger.error(f"Ошибка при инициализации GeminiHandler: {e}")
                import traceback
                logger.error(traceback.format_exc())
        else:
            logger.warning(
                "API ключ Google Gemini не найден в переменных окружения")

        # Инициализируем Mistral API если доступен ключ
        if mistral_api_key:
            try:
                from ...utils.mistral_api import MistralHandler, MISTRAL_AVAILABLE
                if MISTRAL_AVAILABLE:
                    self.mistral_handler = MistralHandler(
                        api_key=mistral_api_key)
                    self._mistral_available = self.mistral_handler.is_available()
                    logger.info(f"MistralHandler инициализирован и доступен: {self._mistral_available}")
                else:
                    logger.warning("Библиотека Mistral не установлена")
            except Exception as e:
                logger.error(f"Ошибка при инициализации MistralHandler: {e}")
                import traceback
                logger.error(traceback.format_exc())
        else:
            logger.warning("API ключ Mistral не найден в переменных окружения")

        # Инициализируем G4F как запасной вариант
        try:
            from ...utils.g4f_handler import G4FHandler, G4F_AVAILABLE
            if G4F_AVAILABLE:
                self.g4f_handler = G4FHandler(api_key=mistral_api_key)
                self._g4f_available = True
                logger.info("G4FHandler инициализирован")
            else:
                logger.warning(
                    "G4F не установлен, этот провайдер будет недоступен")
        except Exception as e:
            logger.error(f"Ошибка при инициализации G4FHandler: {e}")
            import traceback
            logger.error(traceback.format_exc())

        # Логируем информацию о доступных провайдерах
        logger.info(f"ContentGenerator инициализирован (доступные провайдеры: Gemini: {self._gemini_available}, Mistral: {self._mistral_available}, G4F: {self._g4f_available})")

    async def ensure_g4f_handler(self) -> bool:
        """Проверяем и обеспечиваем доступность провайдеров генерации"""
        # Если ни один провайдер не доступен, пробуем переинициализировать
        if not self._gemini_available and not self._mistral_available and not self._g4f_available:
            logger.info(
                "Ни один провайдер генерации не доступен, пробуем переинициализировать")
            return await self.refresh_g4f_handler()

        # Если хотя бы один провайдер доступен, возвращаем True
        return self._gemini_available or self._mistral_available or self._g4f_available

    async def get_generation_queue(self):
        """Lazy initialization of generation queue"""
        if self._generation_queue is None:
            # Import here to avoid circular import
            from ...services.queue.generation_queue import AsyncGenerationQueue
            self._generation_queue = AsyncGenerationQueue(self.session)
            await self._generation_queue.initialize()
        return self._generation_queue

    async def generate_content(
        self,
        user_id: int,
        prompt: str,
        content_type: ContentType,
        use_cache: bool = True,
        force_queue: bool = False,
        extra_params: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Генерирует контент на основе промпта

        Args:
            user_id: ID пользователя
            prompt: Текст промпта
            content_type: Тип контента
            use_cache: Использовать ли кэширование
            force_queue: Принудительно использовать очередь вместо прямой генерации
            extra_params: Дополнительные параметры для генерации

        Returns:
            str: Сгенерированный текст
        """
        try:
            # Логируем детали запроса
            logger.info(f"Генерация контента типа: {content_type.value if hasattr(content_type, 'value') else content_type}")
            logger.info(f"Параметры: user_id={user_id}, use_cache={use_cache}, force_queue={force_queue}")

            if extra_params:
                logger.info(f"Дополнительные параметры: {json.dumps(extra_params, ensure_ascii=False, default=str)[:200]}...")

            # Создаем кэш-ключ
            cache_key = self._create_cache_key(
                prompt, content_type, extra_params)

            # Проверяем кэш, если use_cache=True
            if use_cache:
                cached_content = await self.cache_service.get_cached_data(cache_key)
                if cached_content:
                    logger.info(f"Найден кэшированный контент, длина: {len(cached_content) if isinstance(cached_content, str) else 'не строка'}")
                    return cached_content

            # Валидируем длину промпта
            self._validate_prompt(prompt, content_type)

            # Проверяем и инициализируем G4FHandler
            if not force_queue and await self.ensure_g4f_handler():
                # Пытаемся сгенерировать с использованием G4FHandler
                try:
                    logger.info("Генерация контента через G4FHandler")
                    content = await self._generate_with_g4f(prompt, content_type)
                    if content:
                        # Кэшируем результат, если use_cache=True
                        if use_cache:
                            await self.cache_service.cache_data(cache_key, content, ttl=3600)

                        # Для структурированных данных, проверяем формат
                        if content_type == ContentType.STRUCTURED_DATA:
                            logger.info(f"Проверка формата структурированных данных, длина контента: {len(content)}")
                            try:
                                if isinstance(content, str):
                                    # Для строковых данных, попытка найти
                                    # валидный JSON
                                    content = content.strip()
                                    start_idx = content.find('{')
                                    end_idx = content.rfind('}') + 1

                                    if start_idx >= 0 and end_idx > start_idx:
                                        json_str = content[start_idx:end_idx]
                                        logger.info(f"Извлечен JSON из контента, длина: {len(json_str)}")
                                        # Проверка валидности JSON
                                        try:
                                            json.loads(json_str)
                                            return content
                                        except json.JSONDecodeError as je:
                                            logger.error(
                                                f"Ошибка декодирования JSON: {str(je)}")
                                            logger.error(
                                                f"Фрагмент JSON: {json_str[:200]}...")
                                            # Продолжаем выполнение, попробуем
                                            # резервный метод
                                    else:
                                        logger.error(
                                            "Не удалось найти валидный JSON в сгенерированном контенте")
                                else:
                                    # Если контент уже не строка, возвращаем
                                    # как есть
                                    return content
                            except Exception as e:
                                logger.error(f"Ошибка при проверке формата структурированных данных: {str(e)}")
                                # Продолжаем выполнение, попробуем резервный
                                # метод
                        else:
                            # Для не структурированных данных возвращаем как
                            # есть
                            return content
                except Exception as g4f_error:
                    # Логируем ошибку G4FHandler
                    logger.error(f"Ошибка генерации через G4FHandler: {str(g4f_error)}")
                    logger.info(
                        "Переключение на резервный метод генерации через очередь")

            # Резервный метод: генерация через очередь
            logger.info("Генерация контента через очередь (резервный метод)")
            content = await self._generate_with_queue(user_id, prompt, content_type)

            if content:
                # Кэшируем результат, если use_cache=True
                if use_cache:
                    await self.cache_service.cache_data(cache_key, content, ttl=3600)
                return content
            else:
                logger.error(
                    "Оба метода генерации (G4FHandler и очередь) не смогли сгенерировать контент")
                return "Не удалось сгенерировать контент. Пожалуйста, попробуйте позже или обратитесь в поддержку."

        except Exception as e:
            logger.error(
    f"Критическая ошибка при генерации контента: {
        str(e)}")
            import traceback
            logger.error(f"Трассировка: {traceback.format_exc()}")
            return "Произошла ошибка при генерации контента. Пожалуйста, попробуйте позже."

    async def _save_generation(self, batch: List[Dict[str, Any]]) -> None:
        """Batch save generations"""
        generations = [
            Generation(
                user_id=item["user_id"],
                type=item["type"].value if hasattr(
    item["type"], "value") else item["type"],
                content=item["content"],
                prompt=item["prompt"],
                created_at=datetime.utcnow()
            )
            for item in batch
        ]
        self.session.add_all(generations)
        await self.session.flush()

    async def _get_user_priority(self, user_id: int) -> int:
        """Get user priority for queue"""
        query = await self.query_optimizer.optimize_query(
            select(User).where(User.id == user_id)
        )
        result = await self.session.execute(query)
        user = result.scalar_one_or_none()

        if not user:
            return 0

        # Priority based on tariff and points
        priority = 0
        if user.tariff:
            priority += {
                'tariff_2': 1,
                'tariff_4': 2,
                'tariff_6': 3
            }.get(user.tariff, 0)

        # Up to 5 additional points for points
        priority += min(user.points // 1000, 5)
        return priority

    def _validate_prompt(self,
    prompt: str,
    content_type: Union[str,
     ContentType]) -> None:
        """Validate prompt length based on content type"""
        # Define max lengths for different content types
        max_lengths = {
            # Увеличиваем лимит для планов уроков до 15000 символов
            ContentType.LESSON_PLAN: 15000,
            ContentType.EXERCISE: 15000,  # Увеличиваем лимит для упражнений до 15000 символов
            ContentType.GAME: 15000,  # Увеличиваем лимит для игр до 15000 символов
            ContentType.TRANSCRIPT: 500,
            # Увеличиваем лимит для анализа текста до 15000 символов
            ContentType.TEXT_ANALYSIS: 15000,
            # Увеличиваем лимит для структурированных данных до 30000 символов
            ContentType.STRUCTURED_DATA: 30000,
            ContentType.COURSE: 30000,  # Увеличиваем лимит для генерации курса до 30000 символов
            # Увеличиваем лимит для планов уроков (строковый вариант) до 15000
            # символов
            'lesson_plan': 15000,
            # Увеличиваем лимит для упражнений (строковый вариант) до 15000
            # символов
            'exercise': 15000,
            # Увеличиваем лимит для игр (строковый вариант) до 15000 символов
            'game': 15000,
            'transcript': 500,
            # Увеличиваем лимит для анализа текста (строковый вариант) до 15000
            # символов
            'text_analysis': 15000,
            # Увеличиваем лимит для структурированных данных (строковый
            # вариант) до 30000 символов
            'structured_data': 30000,
            # Увеличиваем лимит для генерации курса (строковый вариант) до
            # 30000 символов
            'course': 30000,
            'image': 200
        }

        # Get max_length based on content_type (can be string or enum)
        max_length = max_lengths.get(content_type, 500)

        if len(prompt) > max_length:
            ct_value = content_type.value if hasattr(
                content_type, 'value') else content_type
            raise ValidationError(f"Prompt too long for {ct_value}")

    @memory_optimized()
    async def generate_lesson_plan(
            self,
            user_id: int,
            course_id: Optional[int] = None,
            lesson_data: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Generate lesson plan with optimization"""
        try:
            # Prepare context for generation
            context = await self._prepare_lesson_context(course_id, lesson_data)

            # Create prompt
            prompt = self._create_lesson_plan_prompt(context)

            # Generate content through queue
            content = await self.generate_content(
                content_type=ContentType.LESSON_PLAN,
                prompt=prompt,
                user_id=user_id,
                extra_params=context
            )

            # Structure result
            lesson_plan = self._structure_lesson_plan(content)

            # If there's a course, link it
            if course_id:
                await self._link_lesson_to_course(
                    course_id,
                    lesson_plan
                )

            return lesson_plan

        except Exception as e:
            logger.error(f"Error generating lesson plan: {str(e)}")
            raise

    async def _prepare_lesson_context(self, course_id: Optional[int], lesson_data: Optional[Dict[
        str, Any]]) -> Dict[
        str, Any]:
        """Prepare context for lesson generation"""
        context = lesson_data or {}

        if course_id:
            # Get course information to provide context
            query = select(Course).where(Course.id == course_id)
            result = await self.session.execute(query)
            course = result.scalar_one_or_none()

            if course:
                context.update({
                    "course_title": course.title,
                    "course_description": course.description,
                    "course_level": course.level,
                    "course_language": course.language
                })

                # Get previous lessons in the course
                lessons_query = select(Lesson).where(
    Lesson.course_id == course_id).order_by(
        Lesson.id.desc()).limit(1)
                result = await self.session.execute(lessons_query)
                previous_lesson = result.scalar_one_or_none()

                if previous_lesson:
                    context["previous_lesson"] = previous_lesson.title
                    context["previous_content"] = previous_lesson.content

        return context

    def _create_lesson_plan_prompt(self, context: Dict[str, Any]) -> str:
        """Create prompt for lesson plan generation"""
        prompt_template = """
        Create a detailed lesson plan with the following parameters:

        Language: {language}
        Level: {level}
        Topic: {topic}
        Previous lesson: {previous_lesson}

        Include the following sections:
        1. Lesson objectives
        2. Required materials
        3. Warm-up activity (5-10 minutes)
        4. Main activities with timing
        5. Practice activities
        6. Assessment
        7. Homework assignment
        8. Additional notes

        Make the lesson interactive, engaging, and appropriate for the specified level.
        """

        # Fill in the template with context values or defaults
        return prompt_template.format(
            language=context.get('language', 'English'),
            level=context.get('level', 'Intermediate'),
            topic=context.get('topic', 'General communication'),
            previous_lesson=context.get('previous_lesson', 'None')
        )

    def _structure_lesson_plan(self, content: str) -> Dict[str, Any]:
        """Structure the raw generated content into a lesson plan format"""
        # Simple parser for the content
        sections = {
            "title": "",
            "objectives": [],
            "materials": [],
            "warm_up": "",
            "main_activities": [],
            "practice": [],
            "assessment": "",
            "homework": ["Домашнее задание 1", "Домашнее задание 2"],
            "notes": ""
        }

        # Very basic parsing - in a real app, you'd want more robust parsing
        current_section = None
        lines = content.split('\n')

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Try to identify sections
            lower_line = line.lower()
            if "objectives" in lower_line or "goals" in lower_line:
                current_section = "objectives"
                continue
            elif "materials" in lower_line or "resources" in lower_line:
                current_section = "materials"
                continue
            elif "warm" in lower_line and ("up" in lower_line or "activity" in lower_line):
                current_section = "warm_up"
                continue
            elif "main" in lower_line and "activit" in lower_line:
                current_section = "main_activities"
                continue
            elif "practice" in lower_line:
                current_section = "practice"
                continue
            elif "assessment" in lower_line or "evaluation" in lower_line:
                current_section = "assessment"
                continue
            elif "homework" in lower_line or "assignment" in lower_line:
                current_section = "homework"
                continue
            elif "notes" in lower_line or "additional" in lower_line:
                current_section = "notes"
                continue
            elif current_section is None and not sections["title"]:
                sections["title"] = line
                continue

            # Process content based on current section
            if current_section == "objectives" and line.startswith("- "):
                sections["objectives"].append(line[2:])
            elif current_section == "materials" and line.startswith("- "):
                sections["materials"].append(line[2:])
            elif current_section == "warm_up":
                sections["warm_up"] += line + "\n"
            elif current_section == "main_activities" and line.startswith("- "):
                sections["main_activities"].append(line[2:])
            elif current_section == "practice" and line.startswith("- "):
                sections["practice"].append(line[2:])
            elif current_section == "assessment":
                sections["assessment"] += line + "\n"
            elif current_section == "homework":
                sections["homework"] += line + "\n"
            elif current_section == "notes":
                sections["notes"] += line + "\n"
            elif current_section:  # Catch-all for non-bullet points in list sections
                if current_section in [
    "warm_up", "assessment", "homework", "notes"]:
                    sections[current_section] += line + "\n"

        return sections

    async def _link_lesson_to_course(
        self, course_id: int, lesson_plan: Dict[str, Any]) -> None:
        """Link lesson to course"""
        lesson = Lesson(
            course_id=course_id,
            title=lesson_plan.get('title', ''),
            content=lesson_plan,
            created_at=datetime.utcnow()
        )
        self.session.add(lesson)
        await self.session.flush()

    @memory_optimized()
    async def generate_exercises(
            self,
            user_id: int,
            params: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Generate exercises with optimization"""
        try:
            # Check parameters
            self._validate_exercise_params(params)

            # Create prompt
            prompt = self._create_exercises_prompt(params)

            # Generate content through queue
            content = await self.generate_content(
                content_type=ContentType.EXERCISE,
                prompt=prompt,
                user_id=user_id,
                extra_params=params
            )

            # Structure exercises
            raw_exercises = self._structure_exercises(content)

            # Подготовка данных для сохранения - добавляем user_id и
            # дополнительные поля
            exercises_to_save = []
            for ex in raw_exercises:
                exercise_data = {
                    "user_id": user_id,
                    "type": ContentType.EXERCISE.value,
                    "content": ex,  # Сохраняем всю структуру упражнения
                    "prompt": prompt,  # Сохраняем промпт, который использовался для генерации
                    "difficulty": params.get("difficulty", "medium")
                }
                exercises_to_save.append(exercise_data)

            # Batch save exercises если список не пустой
            if exercises_to_save:
                await self.batch_processor.process_in_batches(
                    exercises_to_save,
                    self._save_exercises
                )

            return raw_exercises

        except Exception as e:
            logger.error(f"Error generating exercises: {str(e)}")
            raise

    async def _save_exercises(self, batch: List[Dict[str, Any]]) -> None:
        """Batch save exercises"""
        try:
            # Используем существующую модель Generation для сохранения
            # упражнений
            generations = [
                Generation(
                    user_id=item.get("user_id"),
                    type=item.get("type"),
                    # Преобразуем словарь в строку
                    content=str(item.get("content")),
                    # Устанавливаем пустую строку, если prompt нет
                    prompt=str(item.get("prompt", "")),
                    created_at=datetime.utcnow()
                )
                for item in batch if item.get("content")
            ]

            if generations:
                self.session.add_all(generations)
                await self.session.flush()

        except Exception as e:
            logger.error(f"Ошибка при сохранении упражнений: {str(e)}")
            raise

    def _validate_exercise_params(self, params: Dict[str, Any]) -> None:
        """Validate parameters for exercise generation"""
        required_params = ['language', 'topic', 'difficulty', 'quantity']
        for param in required_params:
            if param not in params:
                raise ValidationError(f"Missing required parameter: {param}")

        if not 1 <= params.get('quantity', 0) <= 10:
            raise ValidationError("Quantity must be between 1 and 10")

    def _create_exercises_prompt(self, params: Dict[str, Any]) -> str:
        """Create prompt for exercise generation"""

        # Получаем метаданные или инициализируем пустой словарь
        meta = params.get('meta', {})

        # Формируем инструкции для индивидуальных/групповых занятий
        format_instruction = ""
        if params.get('individual_group') == 'individual':
            format_instruction = """
!!! IMPORTANT !!!
This is an INDIVIDUAL lesson (one-on-one teaching). The exercises should:
- Be designed for one-on-one interaction between teacher and student
- NOT include any pair or group activities
- Focus on personalized feedback and individual practice
- Avoid phrases like "work with a partner" or "discuss in groups"
            """
        elif params.get('individual_group') == 'group':
            format_instruction = """
The exercises should be designed for GROUP teaching:
- Include activities where students can work together
- Incorporate peer interaction and collaborative tasks
- Utilize group dynamics for language practice
            """

        # Формируем инструкции для онлайн/оффлайн занятий
        online_instruction = ""
        if params.get('online_offline') == 'online':
            online_instruction = """
The exercises should be adapted for ONLINE teaching:
- Utilize digital tools and platforms
- Be suitable for screen sharing and virtual interaction
- Consider the limitations of online communication
            """
        elif params.get('online_offline') == 'offline':
            online_instruction = """
The exercises should be adapted for OFFLINE teaching:
- Utilize physical materials and classroom resources
- Take advantage of face-to-face interaction
- Include physical movement and tactile elements when appropriate
            """

        # Дополнительные опции
        additional_options = ""
        if meta.get('includeAnswers', True):
            additional_options += "- Include ANSWER KEYS for all exercises\n"
        if meta.get('includeInstructions', True):
            additional_options += "- Include TEACHER INSTRUCTIONS with suggestions for implementation\n"
        if meta.get('adaptiveDifficulty', False):
            additional_options += "- Provide variations for different proficiency levels within the same exercise\n"

        # Выбранные типы упражнений из метаданных
        selected_types = meta.get('selectedTypes', [])
        types_instruction = ""
        if selected_types:
            types_str = ", ".join(selected_types)
            types_instruction = f"Focus on these exercise types: {types_str}"

        # Выбранные форматы упражнений
        selected_formats = meta.get('selectedFormats', [])
        formats_instruction = ""
        if selected_formats:
            formats_str = ", ".join(selected_formats)
            formats_instruction = f"Use these exercise formats: {formats_str}"

        # Основной шаблон промпта
        prompt_template = """
        Create {quantity} {difficulty} level exercises for {language} language learners.
        Topic: {topic}
Proficiency level: {proficiency}
Exercise Type: {exercise_type}

{types_instruction}
{formats_instruction}
{format_instruction}
{online_instruction}

        Each exercise should include:
1. Clear instructions for students
2. The exercise content
3. Any necessary materials or resources
{additional_options}

        Make the exercises interactive, appropriate for the level, and focused on the topic.
        """

        return prompt_template.format(
            quantity=params.get('quantity', 3),
            difficulty=params.get('difficulty', 'intermediate'),
            language=params.get('language', 'English'),
            topic=params.get('topic', 'General'),
            proficiency=meta.get('proficiency', 'intermediate'),
            exercise_type=params.get('exercise_type', 'grammar'),
            types_instruction=types_instruction,
            formats_instruction=formats_instruction,
            format_instruction=format_instruction,
            online_instruction=online_instruction,
            additional_options=additional_options
        )

    def _structure_exercises(self, content: str) -> List[Dict[str, Any]]:
        """Structure the raw generated content into exercises"""
        exercises = []

        # Журналирование для отладки
        logger.info(f"Начало парсинга упражнений. Длина контента: {
        len(content)} символов")

        try:
            # Проверка наличия разделов ответов и инструкций
            has_answers = "answers" in content.lower(
            ) or "answer key" in content.lower() or "answer keys" in content.lower()
            has_instructions = "teacher instructions" in content.lower(
            ) or "teaching notes" in content.lower()

            logger.info(f"Определение секций: answers={has_answers}, instructions={has_instructions}")

            # Пытаемся разделить контент на упражнения по маркерам
            # Проверяем различные формы маркеров упражнений
            if "exercise" in content.lower():
                sections = re.split(r"(?i)## Exercise \d+:", content)
                logger.info(f"Разделение по 'Exercise N': получено {
        len(sections)} секций")
            elif "упражнение" in content.lower():
                sections = re.split(r"(?i)упражнение\s*\d+[\.:]?", content)
                logger.info(f"Разделение по 'Упражнение N': получено {
        len(sections)} секций")
            else:
                # Если не нашли стандартных маркеров, рассматриваем весь текст
                # как одно упражнение
                logger.info(f"Не найдены стандартные маркеры упражнений. Возвращаем весь контент как одно упражнение.")
                return [{
                    "type": "general",
                    "content": content,
                    "answers": "",
                    "instructions": ""
                }]

            # Убираем первую пустую секцию, если она есть
            if sections and not sections[0].strip():
                sections = sections[1:]

            if not sections:
                logger.warning(
                    "После разделения не найдено упражнений. Возвращаем весь контент как одно упражнение.")
                return [{
                    "type": "general",
                    "content": content,
                    "answers": "",
                    "instructions": ""
                }]

            # Обрабатываем каждую секцию
            for i, section in enumerate(sections, 1):
                if not section.strip():
                    continue

                logger.info(f"Обработка упражнения {i}, длина секции: {
        len(section)} символов")

                exercise = {
                    "type": "general",
                    "content": "",
                    "answers": "",
                    "instructions": ""
                }

                # Ищем секцию ответов (может быть в разных форматах)
                answer_patterns = [
                    r"(?i)###\s*answer\s*keys?.*?$",
                    r"(?i)answer\s*keys?:?.*?$",
                    r"(?i)answers:?.*?$",
                    r"(?i)ответы:?.*?$",
                    r"(?i)solutions?:?.*?$"
                ]

                # Ищем секцию инструкций
                instruction_patterns = [
                    r"(?i)###\s*teacher\s*instructions.*?$",
                    r"(?i)teacher\s*instructions:?.*?$",
                    r"(?i)teaching\s*notes:?.*?$",
                    r"(?i)инструкции\s*для\s*учителя:?.*?$",
                    r"(?i)notes\s*for\s*teacher:?.*?$"
                ]

                content_parts = {}
                current_section = section

                # Извлекаем ответы
                answers_match = None
                for pattern in answer_patterns:
                    matches = re.search(pattern, current_section, re.MULTILINE)
                    if matches:
                        answers_match = matches
                        break

                if answers_match:
                    split_pos = answers_match.start()
                    content_parts['content'] = current_section[:split_pos].strip()
                    content_parts['answers'] = current_section[split_pos:].strip()
                    # Обновляем текущую секцию для дальнейшего поиска
                    current_section = content_parts['content']
                else:
                    content_parts['content'] = current_section
                    content_parts['answers'] = ""

                # Извлекаем инструкции
                instructions_match = None
                for pattern in instruction_patterns:
                    matches = re.search(pattern, current_section, re.MULTILINE)
                    if matches:
                        instructions_match = matches
                        break

                if instructions_match:
                    split_pos = instructions_match.start()
                    # Обновляем содержимое, отделяя инструкции
                    content_parts['instructions'] = current_section[split_pos:].strip(
                    )
                    content_parts['content'] = current_section[:split_pos].strip()
                else:
                    content_parts['instructions'] = ""

                # Если в ответах есть инструкции, обрабатываем их
                for pattern in instruction_patterns:
                    if content_parts['answers']:
                        matches = re.search(
    pattern, content_parts['answers'], re.MULTILINE)
                        if matches:
                            split_pos = matches.start()
                            content_parts['instructions'] = content_parts['answers'][split_pos:].strip(
                            )
                            content_parts['answers'] = content_parts['answers'][:split_pos].strip(
                            )
                            break

                # Заполняем данные упражнения
                exercise['content'] = content_parts['content'].strip()
                exercise['answers'] = content_parts['answers'].strip()
                exercise['instructions'] = content_parts['instructions'].strip()

                # Определяем тип упражнения (если возможно)
                exercise_type_patterns = {
                    "grammar": r"(?i)(grammar|грамматик|tense|время|артикл|предлог|союз|синтакс)",
                    "vocabulary": r"(?i)(vocabulary|словар|лексик|слов|term|термин)",
                    "reading": r"(?i)(reading|чтени|текст|passage|отрыв)",
                    "writing": r"(?i)(writing|письм|composition|сочинени|эссе|essay)",
                    "speaking": r"(?i)(speaking|говорени|диалог|монолог|conversation|разговор)",
                    "listening": r"(?i)(listening|аудировани|слушани)"
                }

                for type_key, pattern in exercise_type_patterns.items():
                    if re.search(pattern, exercise['content']):
                        exercise['type'] = type_key
                        break

                # Логируем результат
                logger.info(f"Упражнение {i} обработано: {len(exercise['content'])} символов контента, " +
                           f"{len(exercise['answers'])} символов ответов, {len(exercise['instructions'])} символов инструкций")

                exercises.append(exercise)

            logger.info(f"Успешно обработано {len(exercises)} упражнений")
            return exercises

        except Exception as e:
            logger.error(
    f"Ошибка при обработке структуры упражнений: {
        str(e)}")
            # В случае ошибки возвращаем весь контент как одно упражнение
            return [{
                "type": "general",
                "content": content,
                "answers": "",
                "instructions": ""
            }]

    @memory_optimized()
    async def generate_game(
            self,
            user_id: int,
            params: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate game with optimization"""
        try:
            # Check parameters
            self._validate_game_params(params)

            # Create prompt
            prompt = self._create_game_prompt(params)

            # Generate content through queue
            content = await self.generate_content(
                content_type=ContentType.GAME,
                prompt=prompt,
                user_id=user_id,
                extra_params=params
            )

            # Structure game
            game = self._structure_game(content)

            return game

        except Exception as e:
            logger.error(f"Error generating game: {str(e)}")
            raise

    def _validate_game_params(self, params: Dict[str, Any]) -> None:
        """Validate parameters for game generation"""
        required_params = ['language', 'topic', 'game_type', 'duration']
        for param in required_params:
            if param not in params:
                raise ValidationError(f"Missing required parameter: {param}")

        if not 5 <= params.get('duration', 0) <= 60:
            raise ValidationError("Duration must be between 5 and 60 minutes")

        # Проверяем формат игры, если он указан
        if 'format' in params and params['format'] not in [
            'individual', 'group']:
            raise ValidationError(
                "Format must be either 'individual' or 'group'")

        # Проверяем тип контента, если он отсутствует, добавляем его
        if 'type' not in params:
            params['type'] = ContentType.GAME

    def _create_game_prompt(self, params: Dict[str, Any]) -> str:
        """Create prompt for game generation"""
        # Определяем формат игры (индивидуальный или групповой)
        format_instruction = ""
        if params.get('format') == 'individual':
            format_instruction = "This game should be designed for individual play (one student with a teacher)."
        elif params.get('format') == 'group':
            format_instruction = "This game should be designed for group play (multiple students)."

        prompt_template = """
        Create a {game_type} game for {language} language learners.
        Topic: {topic}
        Duration: {duration} minutes
        Age group: {age_group}
        {format_instruction}

        Include:
        1. Game title
        2. Required materials
        3. Setup instructions
        4. Game rules
        5. Scoring system
        6. Variations (optional)

        Make the game engaging, interactive, and appropriate for language learning.
        """

        return prompt_template.format(
            game_type=params.get('game_type', 'language'),
            language=params.get('language', 'English'),
            topic=params.get('topic', 'General'),
            duration=params.get('duration', 15),
            age_group=params.get('age_group', 'adults'),
            format_instruction=format_instruction
        )

    def _structure_game(self, content: str) -> Dict[str, Any]:
        """Structure the raw generated content into a game format"""
        game = {
            "title": "",
            "materials": [],
            "setup": "",
            "rules": "",
            "scoring": "",
            "variations": []
        }

        # Basic parsing
        lines = content.split('\n')
        current_section = None

        for line in lines:
            line = line.strip()
            if not line:
                continue

            lower_line = line.lower()
            if game["title"] == "" and current_section is None:
                game["title"] = line
                continue
            elif "materials" in lower_line or "requirements" in lower_line:
                current_section = "materials"
                continue
            elif "setup" in lower_line or "preparation" in lower_line:
                current_section = "setup"
                continue
            elif "rules" in lower_line or "how to play" in lower_line:
                current_section = "rules"
                continue
            elif "scoring" in lower_line or "points" in lower_line:
                current_section = "scoring"
                continue
            elif "variations" in lower_line or "alternatives" in lower_line:
                current_section = "variations"
                continue

            if current_section == "materials" and line.startswith("- "):
                game["materials"].append(line[2:])
            elif current_section == "setup":
                game["setup"] += line + "\n"
            elif current_section == "rules":
                game["rules"] += line + "\n"
            elif current_section == "scoring":
                game["scoring"] += line + "\n"
            elif current_section == "variations" and line.startswith("- "):
                game["variations"].append(line[2:])

        return game

    @memory_optimized()
    async def generate_image(
            self,
            user_id: int,
            prompt: str,
            params: Optional[Dict[str, Any]] = None,
            use_cache: bool = True,
            force_queue: bool = False
    ) -> str:
        """Generate image with optimization"""
        try:
            # Определяем cache_key независимо от use_cache, используя более
            # стабильный md5 хэш
            cache_key = f"image:{hashlib.md5(prompt.encode()).hexdigest()}"

            # Check cache
            if use_cache:
                cached_image = await self.cache_service.get_cached_data(cache_key)
                if cached_image:
                    return cached_image

            # Generate image through queue
            image_url = await self.generate_content(
                content_type=ContentType.IMAGE,
                prompt=prompt,
                user_id=user_id,
                extra_params=params,
                use_cache=use_cache,
                force_queue=force_queue
            )

            # Save image information
            image = Image(
                user_id=user_id,
                url=image_url,
                prompt=prompt,
                created_at=datetime.utcnow()
            )
            self.session.add(image)
            await self.session.flush()

            # Cache result only if use_cache is True
            if use_cache:
                await self.cache_service.cache_data(cache_key, image_url, ttl=3600)

            return image_url

        except Exception as e:
            logger.error(f"Error generating image: {str(e)}")
            raise

    async def _generate_with_g4f(
    self,
    prompt: str,
     content_type: ContentType) -> Optional[str]:
        """
        Генерирует контент с использованием доступных провайдеров
        в порядке приоритета: Gemini -> Mistral -> G4F

        Args:
            prompt: Текст промпта для генерации
            content_type: Тип контента

        Returns:
            Optional[str]: Сгенерированный текст или None в случае ошибки
        """
        try:
            # Адаптируем промпт в зависимости от типа контента
            if content_type == ContentType.IMAGE:
                logger.info(f"Генерация изображения с использованием специализированных провайдеров")
                # Для изображений используем специальный метод
                if self.g4f_handler:
                    image_url = await self.g4f_handler.generate_image(prompt)
                    return image_url
                else:
                    logger.error(
                        "G4FHandler не инициализирован для генерации изображений")
                    return "Не удалось сгенерировать изображение. Провайдер недоступен."
            else:
                # Для текстового контента выбираем провайдера по приоритету

                # 1. Пробуем использовать Gemini API (высший приоритет)
                if self._gemini_available and self.gemini_handler:
                    try:
                        logger.info(f"Начало генерации контента типа {
        content_type.value} с использованием Gemini API")

                        # Получаем сгенерированный контент через Gemini API
                        generated_content = await self.gemini_handler.generate_content(
                            prompt=prompt,
                            temperature=0.7,
                            max_tokens=2048
                        )

                        if generated_content:
                            logger.info(f"Контент успешно сгенерирован через Gemini API, длина: {
        len(generated_content)}")
                            return generated_content
                        else:
                            logger.warning(
                                "Gemini API вернул пустой ответ, переключаемся на Mistral")
                    except Exception as e:
                        logger.error(
    f"Ошибка при генерации через Gemini API: {
        str(e)}")
                        logger.info("Переключаемся на Mistral API")

                # 2. Пробуем использовать Mistral API (средний приоритет)
                if self._mistral_available and self.mistral_handler:
                    try:
                        logger.info(f"Начало генерации контента типа {
        content_type.value} с использованием Mistral API")

                        # Получаем сгенерированный контент через Mistral API
                        generated_content = await self.mistral_handler.generate_content(
                            prompt=prompt,
                            temperature=0.7,
                            max_tokens=2048
                        )

                        if generated_content:
                            logger.info(f"Контент успешно сгенерирован через Mistral API, длина: {
        len(generated_content)}")
                            return generated_content
                        else:
                            logger.warning(
                                "Mistral API вернул пустой ответ, переключаемся на G4F")
                    except Exception as e:
                        logger.error(
    f"Ошибка при генерации через Mistral API: {
        str(e)}")
                        logger.info("Переключаемся на G4F")

                # 3. Используем G4F (низший приоритет)
                if self._g4f_available and self.g4f_handler:
                    logger.info(f"Начало генерации контента типа {
        content_type.value} с использованием G4F")

                    # Получаем модель и провайдер для генерации
                    model_info = await self.g4f_handler.get_available_model()
                    if not model_info:
                        logger.error(
                            "Не удалось получить доступную модель для генерации контента через G4F")
                        return "Не удалось сгенерировать ответ. Пожалуйста, попробуйте еще раз или выберите другую модель."

                    model, provider = model_info
                    logger.info(f"Используем модель G4F {model} (провайдер: {
        provider.__name__ if hasattr(
            provider, '__name__') else provider})")

                    # Получаем сгенерированный контент через G4F
                    generated_content = await self.g4f_handler.generate_content(
                        prompt=prompt,
                        model=model,
                        provider=provider
                    )

                logger.info(f"Контент успешно сгенерирован через G4F, длина: {
        len(generated_content) if generated_content else 0}")

                if generated_content:
                    return generated_content

                logger.error(
                    "Все провайдеры генерации контента недоступны или вернули ошибки")
                return "Не удалось сгенерировать ответ. Пожалуйста, попробуйте еще раз позже."

        except Exception as e:
            logger.error(
    f"Критическая ошибка при генерации контента: {
        str(e)}")
            import traceback
            logger.error(f"Трассировка: {traceback.format_exc()}")
            return "Не удалось сгенерировать ответ из-за технической ошибки. Пожалуйста, попробуйте еще раз позже."

    async def _generate_with_queue(
            self,
            user_id: int,
            prompt: str,
            content_type: ContentType
    ) -> Optional[str]:
        """
        Fallback метод для генерации контента через очередь

        Args:
            user_id: ID пользователя
            prompt: Текст промпта для генерации
            content_type: Тип контента

        Returns:
            Optional[str]: Сгенерированный текст или None в случае ошибки
        """
        try:
            # Получаем приоритет пользователя
            user_priority = 0
            if self.session is not None:
                try:
                    user_priority = await self._get_user_priority(user_id)
                except Exception as e:
                    logger.error(
    f"Ошибка при получении приоритета пользователя: {
        str(e)}")

            # Инициализируем очередь
            queue = None
            try:
                queue = await self.get_generation_queue()
            except Exception as e:
                logger.error(
    f"Ошибка при получении очереди генерации: {
        str(e)}")
                return None

            if queue is None:
                logger.error("Очередь генерации равна None")
                return None

            # Добавляем задачу в очередь с приоритетом
            task_id = await queue.add_to_queue(
                user_id=user_id,
                content_type=content_type.value,
                prompt=prompt,
                priority=user_priority
            )

            # Ожидаем завершения генерации с таймаутом
            timeout = 300  # 5 минут
            start_time = datetime.utcnow()

            while True:
                status = await queue.get_status(task_id)
                if status['status'] == 'completed':
                    return status['result']
                elif status['status'] == 'error':
                    error_message = status.get('error', 'Неизвестная ошибка')
                    logger.error(
    f"Ошибка при генерации контента через очередь: {error_message}")
                    return None

                # Проверяем таймаут
                if (datetime.utcnow() - start_time).total_seconds() > timeout:
                    logger.error(
    f"Превышено время ожидания генерации через очередь ({timeout} секунд)")
                    return None

                # Небольшая пауза перед следующей проверкой
                await asyncio.sleep(1)

        except Exception as e:
            logger.error(
    f"Ошибка при генерации контента через очередь: {
        str(e)}")
            return None

    async def get_g4f_status(self):
        """
        Получить текущий статус всех провайдеров генерации

        Returns:
            Dict: Статус доступности и информация о провайдерах
        """
        try:
            # Проверяем доступность провайдеров
            await self.ensure_g4f_handler()

            # Собираем информацию о всех провайдерах
            status = {
                "available": self._gemini_available or self._mistral_available or self._g4f_available,
                "providers": {
                    "gemini": {
                        "available": self._gemini_available,
                        "model": "gemini-1.5-pro" if self._gemini_available else None,
                    },
                    "mistral": {
                        "available": self._mistral_available,
                        "model": "open-mistral-nemo" if self._mistral_available else None,
                    },
                    "g4f": {
                        "available": self._g4f_available,
                    }
                }
            }

            # Получаем информацию о модели G4F если доступна
            if self._g4f_available and self.g4f_handler:
                try:
                    model_info = await self.g4f_handler.get_available_model()
                    if model_info:
                        model, provider = model_info
                        status["providers"]["g4f"]["model"] = str(model)
                        status["providers"]["g4f"]["provider"] = provider.__name__ if hasattr(
                            provider, '__name__') else str(provider)
                except Exception as e:
                    logger.error(
    f"Ошибка при получении информации о модели G4F: {e}")
                    status["providers"]["g4f"]["error"] = str(e)

            return status

        except Exception as e:
            logger.error(f"Ошибка при получении статуса провайдеров: {e}")
            return {
                "available": False,
                "error": str(e)
            }

    def set_generation_timeout(self, timeout: int):
        """
        Установить таймаут для генерации контента

        Args:
            timeout: Таймаут в секундах
        """
        if hasattr(self, 'g4f_handler'):
            self.g4f_handler.set_timeout(timeout)
            logger.info(f"Установлен таймаут генерации контента: {timeout} секунд")

    async def clear_content_cache(
    self, content_type: Optional[ContentType] = None):
        """
        Очистить кэш сгенерированного контента

        Args:
            content_type: Тип контента для очистки или None для очистки всего кэша
        """
        try:
            if content_type:
                # Очищаем кэш для конкретного типа контента
                pattern = f"*{content_type.value}*"
                deleted = await self.cache_service.invalidate_pattern(pattern)
                logger.info(f"Очищено {deleted} записей кэша для типа контента {
        content_type.value}")
            else:
                # Очищаем весь кэш контента
                deleted = await self.cache_service.invalidate_pattern("*")
                logger.info(f"Очищено {deleted} записей кэша контента")

            return deleted
        except Exception as e:
            logger.error(f"Ошибка при очистке кэша контента: {str(e)}")
            raise

    # Context manager methods
    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.session.close()

    async def refresh_g4f_handler(self) -> bool:
        """Обновляет обработчик генерации и проверяет его доступность"""
        try:
            # Обновляем ключи API
            self._gemini_api_key = os.getenv("GEMINI_API_KEY", "")
            self._mistral_api_key = os.getenv("MISTRAL_API_KEY", "")

            # Проверяем доступность Gemini
            self._gemini_available = bool(self._gemini_api_key) and await self.check_gemini_available()
            if self._gemini_available:
                logger.info("Gemini API доступен")
            else:
                logger.warning("Gemini API недоступен")

            # Проверяем доступность Mistral
            self._mistral_available = bool(self._mistral_api_key) and await self.check_mistral_available()
            if self._mistral_available:
                logger.info("Mistral API доступен")
            else:
                logger.warning("Mistral API недоступен")

            # Проверяем доступность G4F
            g4f_result = True

            # Создаем обработчик G4F если еще не создан
            if not self.g4f_handler:
                try:
                    self.g4f_handler = G4FHandler(self.session)
                    self._g4f_available = True
                    logger.info("G4F обработчик создан успешно")
                except Exception as e:
                    logger.error(f"Ошибка при создании G4F обработчика: {e}")
                    self._g4f_available = False
                    g4f_result = False

            # Проверяем доступность G4F
            if self.g4f_handler:
                try:
                    self._g4f_available = await self.g4f_handler.check_available()
                    if self._g4f_available:
                        logger.info("G4F доступен")
                    else:
                        logger.warning("G4F недоступен")
                except Exception as e:
                    logger.error(f"Ошибка при проверке G4F: {e}")
                    self._g4f_available = False
                    g4f_result = False

            # Результат обновления - успешно ли обновлены все провайдеры
            return g4f_result and (
    self._gemini_available or self._mistral_available or self._g4f_available)

        except Exception as e:
            logger.error(f"Ошибка при обновлении обработчика G4F: {e}")
            self._g4f_available = False
            return False

    async def generate_comprehension_test(
        self,
        text: str,
        language: str,
        question_count: int = 5,
        difficulty: str = "medium",
        **kwargs
    ) -> str:
        """
        Генерирует вопросы к тексту

        Args:
            text (str): Текст, на основе которого генерируются вопросы
            language (str): Язык текста
            question_count (int): Количество вопросов
            difficulty (str): Уровень сложности (easy, medium, hard)
            **kwargs: Дополнительные параметры

        Returns:
            str: Сгенерированные вопросы к тексту в формате Markdown
        """
        try:
            user_id = kwargs.get('user_id', 1)
            logger.info(f"Generating comprehension questions with {question_count} questions for text in {language}, difficulty: {difficulty}")

            # Проверяем параметры
            if not 1 <= question_count <= 15:
                raise ValidationError(
                    "Question count must be between 1 and 15")

            if difficulty not in ["easy", "medium", "hard"]:
                logger.warning(
    f"Unknown difficulty level: {difficulty}, using 'medium' as default")
                difficulty = "medium"

            # Создаем промпт для теста на понимание
            prompt = self._create_comprehension_test_prompt(
                text, language, question_count, difficulty)

            # Генерируем контент
            content = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={
    "difficulty": difficulty,
     "question_count": question_count}
            )

            # Заменяем заголовок "Тест на понимание текста" на "Вопросы по
            # тексту"
            is_russian = language.lower() in ["russian", "русский", "ru"]

            if is_russian:
                content = content.replace(
    "# Тест на понимание текста",
     "# Вопросы по тексту")
                content = content.replace(
    "## Тест на понимание текста",
     "# Вопросы по тексту")
            else:
                content = content.replace(
    "# Reading Comprehension Test", "# Text Questions")
                content = content.replace(
    "## Reading Comprehension Test", "# Text Questions")

            # Обрабатываем экранированные символы
            content = content.replace("\\n", "\n").replace("\\\\", "\\")

            # Возвращаем сгенерированный тест
            return content

        except Exception as e:
            logger.error(f"Error generating comprehension test: {str(e)}")
            raise

    def _create_comprehension_test_prompt(
    self,
    text: str,
    language: str,
    question_count: int,
     difficulty: str) -> str:
        """Создает промпт для теста на понимание текста"""

        difficulty_descriptions = {
            "easy": "basic comprehension questions suitable for beginners",
            "medium": "moderate difficulty questions requiring good understanding",
            "hard": "challenging questions requiring deep analysis and inference"
        }

        diff_description = difficulty_descriptions.get(
            difficulty, "moderate difficulty questions")

        # Определяем языковые параметры на основе указанного языка
        language_codes = {
            "english": {"code": "en", "native": "English"},
            "spanish": {"code": "es", "native": "Español"},
            "french": {"code": "fr", "native": "Français"},
            "german": {"code": "de", "native": "Deutsch"},
            "italian": {"code": "it", "native": "Italiano"},
            "chinese": {"code": "zh", "native": "中文"},
            "japanese": {"code": "ja", "native": "日本語"},
            "korean": {"code": "ko", "native": "한국어"},
            "turkish": {"code": "tr", "native": "Türkçe"},
            "russian": {"code": "ru", "native": "Русский"},
            "arabic": {"code": "ar", "native": "العربية"}
        }

        language_info = language_codes.get(
    language.lower(), {
        "code": "en", "native": "English"})
        language_code = language_info["code"]
        language_native = language_info["native"]

        # Определяем, является ли язык русским для особого форматирования
        is_russian = language.lower() in ["russian", "русский", "ru"]
        title = "Вопросы по тексту" if is_russian else "Text Questions"

        # Создаем промпт по структуре CARE (Context, Ask, Rules, Examples)
        prompt = f"""
# RESPOND ONLY IN {language_native.upper()} ({language_code})

# CONTEXT:
I am working with a text in {language_native} that contains approximately {len(text.split())} words.
The text begins with: {text[:100]}...
The difficulty level requested is: {difficulty} ({diff_description})

# ASK:
Create {question_count} multiple-choice questions based on the provided text. The questions should help assess comprehension of the text.

# IMPORTANT LANGUAGE INSTRUCTION:
- The content MUST be created in {language_native} language ({language_code})
- All questions, options, and answers MUST be written in {language_native}
- The title should be "{title}"
- All content must be formatted in Markdown
- DO NOT translate any part of the text or questions into any other language
- Use ONLY {language_native} for ALL content including titles, questions, options, and explanations

# RULES:
- Start with a main heading: "# {title}"
- Each question must be clearly numbered and formatted with a colored number using this exact format:
  "Вопрос 1:" for Russian or "Question 1:" for other languages
- Use exactly 4 options (A, B, C, D) for each question
- For each question's options, format them like this:
  A. First option
  B. Second option
  C. Third option
  D. Fourth option
- Mark the correct answer with a ✓ symbol at the beginning of the line
- After the options, include a section titled "Правильный ответ:" for Russian or "Correct Answer:" for other languages that shows the correct option
- Add a separator "---" between questions
- All questions and answers must be based solely on the text content
- Questions should be challenging but fair at the {difficulty} level
- Ensure all formatting is consistent throughout

# EXAMPLE FORMAT (in Russian):
# Вопросы по тексту

Вопрос 1: [Text of the question]

Варианты ответов:

A. Option one
B. Option two
C. ✓ Correct option
D. Option four

Правильный ответ: C. ✓ Correct option

---

Вопрос 2: [Text of the second question]
...

# THE TEXT:
{text}

Now create well-structured multiple-choice questions based on this text in {language_native} language following the exact format specified.
"""

        return prompt

    @memory_optimized()
    async def generate_titles(
        self,
        text: str,
        language: str,
        count: int = 4,
        **kwargs
    ) -> TitlesAnalysis:
        """
        Генерирует заголовки для текста

        Args:
            text (str): Текст, для которого генерируются заголовки
            language (str): Язык текста
            count (int): Количество заголовков для генерации
            **kwargs: Дополнительные параметры

        Returns:
            TitlesAnalysis: Объект с заголовками и индексом рекомендуемого заголовка
        """
        try:
            user_id = kwargs.get('user_id', 1)
            logger.info(f"Generating {count} titles for text in {language}")

            # Проверяем параметры
            if not 1 <= count <= 10:
                raise ValidationError("Title count must be between 1 and 10")

            # Создаем промпт для генерации заголовков
            prompt = self._create_titles_prompt(text, language, count)

            # Генерируем контент
            content = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={"count": count, "action": "generate_titles"}
            )

            # Парсим результат и извлекаем заголовки
            titles_data = self._parse_titles_from_content(content)
            titles = titles_data["titles"]
            recommended_index = titles_data["recommended_index"]

            # Убеждаемся, что у нас есть правильное количество заголовков
            if len(titles) < count:
                logger.warning(
    f"Received fewer titles than requested ({
        len(titles)} < {count}), filling with placeholders")
                # Добавляем плейсхолдеры, если получили меньше заголовков, чем
                # запрошено
                titles.extend(
                    [f"Title {i + 1}" for i in range(len(titles), count)])
            elif len(titles) > count:
                logger.warning(
    f"Received more titles than requested ({
        len(titles)} > {count}), truncating")
                titles = titles[:count]
                # Корректируем индекс рекомендуемого заголовка, если он выходит
                # за границы
                if recommended_index >= count:
                    recommended_index = 0

            # Возвращаем объект TitlesAnalysis
            return TitlesAnalysis(
                titles=titles,
                recommended_index=recommended_index
            )

        except Exception as e:
            logger.error(f"Error generating titles: {str(e)}")
            raise

    def _create_titles_prompt(
    self,
    text: str,
    language: str,
     count: int) -> str:
        """Создает промпт для генерации заголовков"""

        # Определяем языковые параметры на основе указанного языка
        language_codes = {
            "english": {"code": "en", "native": "English"},
            "spanish": {"code": "es", "native": "Español"},
            "french": {"code": "fr", "native": "Français"},
            "german": {"code": "de", "native": "Deutsch"},
            "italian": {"code": "it", "native": "Italiano"},
            "chinese": {"code": "zh", "native": "中文"},
            "japanese": {"code": "ja", "native": "日本語"},
            "korean": {"code": "ko", "native": "한국어"},
            "turkish": {"code": "tr", "native": "Türkçe"},
            "russian": {"code": "ru", "native": "Русский"},
            "arabic": {"code": "ar", "native": "العربية"}
        }

        language_info = language_codes.get(
    language.lower(), {
        "code": "en", "native": "English"})
        language_code = language_info["code"]
        language_native = language_info["native"]

        # Формируем промпт для генерации заголовков
        prompt = f"""
# RESPOND ONLY IN {language_native.upper()} ({language_code})

# CONTEXT:
I have a text in {language_native} that contains approximately {len(text.split())} words.
The text begins with: {text[:100]}...

# ASK:
Generate {count} distinct and creative titles for this text.

# IMPORTANT LANGUAGE INSTRUCTION:
- The titles MUST be created in {language_native} language ({language_code})
- DO NOT translate titles into any other language
- Use ONLY {language_native} for ALL titles

# RULES:
- Create exactly {count} titles
- One of the titles MUST be accurate and directly relevant to the text content
- Titles should be catchy, engaging, and appropriate for the text
- Titles should be concise (typically 3-10 words)
- Titles should vary in style (e.g., question, statement, metaphorical)
- Each title should be unique and different from the others
- Number each title in the format: "1. [Title text]"
- Mark the most accurate and relevant title with a ✓ symbol at the end
- Do not include quotes or extra formatting around the titles

# EXAMPLE OUTPUT:
1. The Surprising Benefits of Daily Exercise ✓
2. From Couch to Marathon: A Journey of Transformation
3. Your Body's Hidden Potential: Unlock It Through Movement
4. Exercise: The Free Medicine That Changes Lives

# FINAL REMINDER:
You MUST create ALL titles in {language_native} language ONLY.
Don't forget to mark the most accurate and relevant title with a ✓ symbol.

# THE TEXT:
{text}

Now generate {count} unique and engaging titles for this text.
"""

        return prompt

    def _parse_titles_from_content(self, content: str) -> dict:
        """Извлекает заголовки из сгенерированного контента"""
        titles = []
        recommended_index = -1  # Индекс рекомендуемого заголовка

        # Ищем строки, начинающиеся с числа и точки, за которым следует текст
        pattern = r'^\s*(\d+)\.?\s*(.+?)(\s*✓)?\s*$'

        for line in content.split('\n'):
            line = line.strip()
            if not line:
                continue

            match = re.match(pattern, line)
            if match:
                title_number = int(match.group(1)) - 1  # Индекс с нуля
                title_text = match.group(2).strip()
                is_recommended = bool(match.group(3))

                # Добавляем заголовок в список
                titles.append(title_text)

                # Если это рекомендуемый заголовок, запоминаем его индекс
                if is_recommended:
                    recommended_index = title_number

        # Если не удалось найти заголовки в нужном формате, пробуем другой
        # подход
        if not titles:
            # Разделяем по пустым строкам и берем первые строки каждого раздела
            sections = [s.strip() for s in content.split('\n\n')]
            for section in sections:
                if section and not section.startswith('#'):
                    lines = section.split('\n')
                    for line in lines:
                        line = line.strip()
                        # Ищем символ рекомендованного заголовка
                        is_recommended = '✓' in line
                        if is_recommended:
                            # Этот заголовок будет рекомендуемым
                            recommended_index = len(titles)

                        # Удаляем метку из заголовка
                        clean_line = line.replace('✓', '').strip()

                        if clean_line and len(
                            clean_line) <= 100:  # Разумное ограничение для заголовка
                            titles.append(clean_line)
                            break

        # Если рекомендуемый заголовок не был явно указан, выбираем первый
        if recommended_index == -1 and titles:
            recommended_index = 0

        # Убедимся, что индекс рекомендуемого заголовка в допустимом диапазоне
        if recommended_index >= len(titles):
            recommended_index = 0 if titles else -1

        # Возвращаем заголовки и информацию о рекомендуемом
        return {
            "titles": titles,
            "recommended_index": recommended_index
        }

    @memory_optimized()
    async def summarize_text(
        self,
        text: str,
        max_length: int = None,
        level: str = None,
        **kwargs
    ) -> str:
        """
        Генерирует саммари текста

        Args:
            text (str): Текст, для которого генерируется саммари
            max_length (int, optional): Максимальная длина саммари в словах
            level (str, optional): Уровень владения языком (a1, a2, b1, b2, c1, c2, etc.)
            **kwargs: Дополнительные параметры

        Returns:
            str: Сгенерированное саммари
        """
        try:
            user_id = kwargs.get('user_id', 1)
            language = kwargs.get('language', 'russian')

            # Карта соответствия уровней и длины саммари
            level_to_length = {
                # CEFR для европейских языков
                'a1': 50,    # Начальный - очень короткое, простое саммари
                'a2': 75,    # Элементарный - короткое, простое саммари
                'b1': 150,   # Средний - среднее по длине, базовые конструкции
                'b2': 200,   # Средне-продвинутый - умеренно длинное
                'c1': 300,   # Продвинутый - длинное, детализированное
                'c2': 400,   # Свободное владение - очень детальное и длинное

                # HSK для китайского
                'hsk1': 50,
                'hsk2': 75,
                'hsk3': 125,
                'hsk4': 200,
                'hsk5': 300,
                'hsk6': 400,
                'hsk7-9': 450,

                # JLPT для японского
                'n5': 50,
                'n4': 100,
                'n3': 200,
                'n4': 300,
                'n1': 450,

                # TOPIK для корейского
                'topik1': 50,
                'topik2': 100,
                'topik3': 150,
                'topik4': 250,
                'topik5': 350,
                'topik6': 450,

                # Для русского (ТРКИ)
                'tea': 50,
                'tba': 100,
                't1': 200,
                't2': 300,
                't3': 400,
                't4': 450,

                # Для арабского (общие уровни)
                'beginner': 50,
                'elementary': 100,
                'intermediate': 200,
                'advanced': 300,
                'superior': 400,
                'native': 450
            }

            # Если указан уровень, определяем длину на его основе
            if level and level.lower() in level_to_length:
                actual_max_length = level_to_length[level.lower()]
                logger.info(f"Using level '{level}' to determine max_length: {actual_max_length}")
            elif max_length is not None:
                # Если указана точная длина, используем её
                actual_max_length = max_length
            # Проверяем параметры
                if not 50 <= actual_max_length <= 500:
                    logger.warning(
    f"Invalid max_length: {actual_max_length}, using default of 200")
                    actual_max_length = 200
                else:
                    # По умолчанию используем средний уровень
                    logger.warning(
                        "Neither level nor max_length specified, using default max_length of 200")
                    actual_max_length = 200

            logger.info(f"Generating summary with max length {actual_max_length} for text of length {
        len(text)}")

            # Создаем промпт для генерации саммари
            prompt = self._create_summary_prompt(
    text, language, actual_max_length, level)

            # Генерируем контент
            content = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={"max_length": actual_max_length, "level": level}
            )

            return content

        except Exception as e:
            logger.error(f"Error generating summary: {str(e)}")
            raise

    def _create_summary_prompt(
    self,
    text: str,
    language: str,
    max_length: int,
     level: str = None) -> str:
        """Создает промпт для генерации саммари"""

        # Определяем языковые параметры на основе указанного языка
        language_codes = {
            "english": {"code": "en", "native": "English"},
            "spanish": {"code": "es", "native": "Español"},
            "french": {"code": "fr", "native": "Français"},
            "german": {"code": "de", "native": "Deutsch"},
            "italian": {"code": "it", "native": "Italiano"},
            "chinese": {"code": "zh", "native": "中文"},
            "japanese": {"code": "ja", "native": "日本語"},
            "korean": {"code": "ko", "native": "한국어"},
            "turkish": {"code": "tr", "native": "Türkçe"},
            "russian": {"code": "ru", "native": "Русский"},
            "arabic": {"code": "ar", "native": "العربية"}
        }

        language_info = language_codes.get(
    language.lower(), {
        "code": "en", "native": "English"})
        language_code = language_info["code"]
        language_native = language_info["native"]

        # Добавляем инструкции в соответствии с уровнем
        level_instructions = ""
        if level:
            if level.lower().startswith('a'):
                level_instructions = f"""
# LANGUAGE LEVEL INSTRUCTIONS (Level {level.upper()}):
- Use very simple vocabulary appropriate for beginner level
- Use short, simple sentences with basic grammar structures
- Avoid complex sentences, idioms, and advanced expressions
- Focus on the most basic and essential information only
- Use common words and phrases that beginners would understand
- Use present tense predominantly, minimizing complex verb forms
"""
            elif level.lower().startswith('b'):
                level_instructions = f"""
# LANGUAGE LEVEL INSTRUCTIONS (Level {level.upper()}):
- Use vocabulary appropriate for intermediate level
- Use a mix of simple and some compound sentences
- Include some common expressions and idioms, but avoid very advanced ones
- Provide a more detailed overview with moderate complexity
- Use a variety of tenses, but limit very complex grammatical structures
"""
            elif level.lower().startswith('c') or level.lower() in ['native', 'superior', 't3', 't4', 'hsk6', 'hsk7-9', 'n1']:
                level_instructions = f"""
# LANGUAGE LEVEL INSTRUCTIONS (Level {level.upper()}):
- Use rich, varied vocabulary appropriate for advanced level
- Use complex sentence structures, including compound and complex sentences
- Include idiomatic expressions, specialized terminology, and nuanced language
- Provide detailed information with significant depth and complexity
- Use a full range of grammatical structures, including advanced ones
- Demonstrate sophisticated language comparable to educated native usage
"""
            else:
                # Промежуточные уровни или уровни для других языковых систем
                level_instructions = f"""
# LANGUAGE LEVEL INSTRUCTIONS (Level {level.upper()}):
- Adapt vocabulary and grammar to the specified level ({level})
- Balance simplicity and complexity appropriate for this level
- Use language structures commonly taught at this level
- Ensure the summary is challenging but comprehensible for learners at this level
"""

        # Формируем промпт для генерации саммари
        prompt = f"""
# RESPOND ONLY IN {language_native.upper()} ({language_code})

# CONTEXT:
I have a text in {language_native} that contains approximately {len(text.split())} words.
I need a summary with EXACTLY AND PRECISELY {max_length} words - NOT LESS, NOT MORE.
This is a STRICT REQUIREMENT - the summary MUST contain {max_length} words.

{level_instructions}

# ASK:
Create a detailed summary of the provided text using EXACTLY {max_length} words.
DO NOT create a summary shorter than {max_length} words under any circumstances.
IF your summary is shorter than {max_length} words, add more details from the original text to reach EXACTLY {max_length} words.

# IMPORTANT LANGUAGE INSTRUCTION:
- The summary MUST be created in {language_native} language ({language_code})
- DO NOT translate the summary into any other language
- Use ONLY {language_native} for ALL content
- The summary must be in plain text format

# RULES:
- Your summary MUST contain EXACTLY {max_length} words (±1 word maximum deviation)
- Count each word carefully during writing
- Capture the main ideas, key points, AND sufficient details from the original text
- Include enough details to REACH the {max_length} word count - this is MANDATORY
- DO NOT make the summary shorter than {max_length} words
- Maintain the original meaning and intent of the text
- Organize the summary in a logical flow
- Do not include your own opinions or interpretations
- Do not add information that is not present in the original text
- If the summary is approaching {max_length} words, adjust detail level to meet exact count

# WORD COUNTING METHODOLOGY:
1. Split the text by spaces to count words
2. Before submitting, count the total words in your summary
3. If the count is less than {max_length}, add more details until you reach EXACTLY {max_length} words
4. If the count is more than {max_length}, remove minor details until you reach EXACTLY {max_length} words

# FINAL REMINDER:
You MUST create the summary in {language_native} language ONLY.
The summary MUST contain EXACTLY {max_length} words - not fewer, not more.
Double-check your word count before submitting.

# THE TEXT:
{text}

Now generate a summary of this text with EXACTLY {max_length} words. Before submitting your answer, count the words to verify it is EXACTLY {max_length} words.
"""

        return prompt

    @memory_optimized()
    async def generate_summaries(
        self,
        text: str,
        language: str = "russian",
        **kwargs
    ) -> str:
        """
        Генерирует три варианта саммари разной длины для текста

        Args:
            text (str): Текст, для которого генерируются саммари
            language (str): Язык текста
            **kwargs: Дополнительные параметры

        Returns:
            str: Сгенерированные саммари в формате Markdown
        """
        try:
            user_id = kwargs.get('user_id', 1)
            logger.info(f"Generating three summaries of different lengths for text in {language}")

            # Создаем промпт для генерации саммари разной длины
            prompt = self._create_multiple_summaries_prompt(text, language)

            # Генерируем контент
            content = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id
            )

            return content

        except Exception as e:
            logger.error(f"Error generating multiple summaries: {str(e)}")
            raise

    def _create_multiple_summaries_prompt(
    self, text: str, language: str) -> str:
        """Создает промпт для генерации нескольких саммари разной длины"""

        # Определяем языковые параметры на основе указанного языка
        language_codes = {
            "english": {"code": "en", "native": "English"},
            "spanish": {"code": "es", "native": "Español"},
            "french": {"code": "fr", "native": "Français"},
            "german": {"code": "de", "native": "Deutsch"},
            "italian": {"code": "it", "native": "Italiano"},
            "chinese": {"code": "zh", "native": "中文"},
            "japanese": {"code": "ja", "native": "日本語"},
            "korean": {"code": "ko", "native": "한국어"},
            "turkish": {"code": "tr", "native": "Türkçe"},
            "russian": {"code": "ru", "native": "Русский"},
            "arabic": {"code": "ar", "native": "العربية"}
        }

        language_info = language_codes.get(
    language.lower(), {
        "code": "en", "native": "English"})
        language_code = language_info["code"]
        language_native = language_info["native"]

        # Формируем промпт для генерации нескольких саммари
        prompt = f"""
# RESPOND ONLY IN {language_native.upper()} ({language_code})

# CONTEXT:
I am working with a text in {language_native} that contains approximately {len(text.split())} words and {len(text.split('.')) + len(text.split('!')) + len(text.split('?')) - 2} sentences.
The text begins with: {text[:100]}...

# ASK:
Create three different summaries of the text at different levels of detail:
1. Brief summary (1-2 sentences)
2. Medium summary (3-5 sentences)
3. Detailed summary (6-10 sentences)

# IMPORTANT LANGUAGE INSTRUCTION:
- The summaries MUST be created in {language_native} language ({language_code})
- DO NOT translate into any other language
- Use ONLY {language_native} for ALL content including titles and summaries
- Format the response in Markdown with clear headings for each summary type

# RULES:
- Each summary must accurately reflect the main content of the text
- The brief summary should capture only the most essential information
- The medium summary should include main ideas and key supporting details
- The detailed summary should cover all major aspects of the text, including important details
- Maintain the logical structure and flow of the original text
- Use your own wording rather than copying sentences directly from the original
- Do not add information that is not present in the original text
- Format the response in Markdown with clear headings for each summary type
- Ensure that each summary is coherent and stands on its own

# EXAMPLE OUTPUT:
# Резюме текста

## Краткое резюме (1-2 предложения):
Текст рассматривает влияние социальных сетей на современное общество, выделяя как положительные аспекты в виде расширения коммуникационных возможностей, так и отрицательные последствия в форме зависимости и ухудшения психического здоровья.

## Среднее резюме (3-5 предложений):
Текст анализирует двойственное влияние социальных сетей на общество. С одной стороны, они расширяют возможности коммуникации, облегчают доступ к информации и способствуют формированию новых сообществ по интересам. С другой стороны, автор отмечает растущую проблему цифровой зависимости, ухудшение психического здоровья пользователей и распространение недостоверной информации. В заключение предлагаются меры по более осознанному использованию социальных платформ.

## Подробное резюме (6-10 предложений):
Текст посвящен комплексному анализу роли социальных сетей в современном обществе. Автор начинает с исторического обзора развития социальных платформ от простых форумов до сложных экосистем. Далее подробно рассматриваются положительные аспекты: беспрецедентные возможности для коммуникации вне географических границ, демократизация доступа к информации, возможности для самовыражения и формирование сообществ по интересам. В противовес этому анализируются негативные последствия: рост цифровой зависимости, документально подтвержденное ухудшение психического здоровья подростков, проблемы конфиденциальности и распространение дезинформации. Особое внимание уделяется феномену "эхо-камер", усиливающих поляризацию общества. Автор приводит данные исследований, демонстрирующих корреляцию между временем, проведенным в социальных сетях, и уровнем тревожности. В заключение предлагаются рекомендации по более сбалансированному использованию социальных платформ, включая "цифровую гигиену" и развитие критического мышления.

# FINAL REMINDER:
You MUST create ALL summaries in {language_native} language ONLY.
Format the response with proper Markdown headings and sections.

# THE TEXT:
{text}

Now create three well-structured summaries at different levels of detail for this text.
"""

        return prompt

    @memory_optimized()
    async def detect_text_level(
        self,
        text: str,
        language: str,
        **kwargs
    ) -> TextLevelAnalysis:
        """
        Определение уровня сложности текста

        Args:
            text (str): Текст для анализа
            language (str): Язык текста
            **kwargs: Дополнительные параметры

        Returns:
            TextLevelAnalysis: Результат анализа, содержащий как markdown_content, так и level
        """
        try:
            import json
            import re

            user_id = kwargs.get('user_id', 1)

            # Определяем систему уровней в зависимости от языка
            language_system = {
                "english": "CEFR (A1-C2)",
                "spanish": "CEFR (A1-C2)",
                "french": "CEFR (A1-C2)",
                "german": "CEFR (A1-C2)",
                "italian": "CEFR (A1-C2)",
                "turkish": "CEFR (A1-C2)",
                "chinese": "HSK (1-6)",
                "japanese": "JLPT (N5-N1)",
                "korean": "TOPIK (1-6)",
                "russian": "ТРКИ (ТЭУ-ТРКИ-4)",
                "arabic": "ACTFL (Beginner-Superior)"
            }

            level_system = language_system.get(
                language.lower(), "CEFR (A1-C2)")

            logger.info(f"Analyzing text level using {level_system} for language: {language}")

            # Создаем промпт для определения уровня текста
            prompt = self._create_text_level_prompt(
                text, language, level_system)

            # Генерируем контент
            json_response = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={"action": "detect_text_level"}
            )

            logger.info(f"Received text level analysis JSON (length: {
        len(json_response)})")

            # Пытаемся извлечь JSON из ответа
            try:
                # Если в ответе есть код JSON, удаляем его обертку
                json_match = re.search(
    r'```(?:json)?\s*(.*?)\s*```', json_response, re.DOTALL)
                if json_match:
                    json_str = json_match.group(1)
                else:
                    json_str = json_response

                # Парсим JSON
                analysis_data = json.loads(json_str)

                # Проверяем наличие всех необходимых полей
                required_fields = [
    "level",
    "explanation",
    "vocabulary_analysis",
    "grammar_analysis",
    "sentence_structure",
     "recommendations"]
                for field in required_fields:
                    if field not in analysis_data:
                        analysis_data[field] = f"[Отсутствует информация о {field}]"

                # Создаем форматированный Markdown
                markdown_content = f"""
# Анализ уровня текста

## Уровень: {analysis_data["level"]}

## Объяснение
{analysis_data["explanation"]}

## Анализ словарного запаса
{analysis_data["vocabulary_analysis"]}

## Анализ грамматики
{analysis_data["grammar_analysis"]}

## Структура предложений
{analysis_data["sentence_structure"]}

## Рекомендации
{analysis_data["recommendations"]}
"""

                return TextLevelAnalysis(
                    markdown_content=markdown_content,
                    level=analysis_data["level"],
                    raw_analysis=analysis_data
                )

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON response: {str(e)}")
                # Если не удалось распарсить JSON, возвращаем исходный ответ
                return TextLevelAnalysis(
                    markdown_content=f"## Ошибка парсинга JSON\n\nПолученный ответ не является корректным JSON:\n\n```\n{json_response}\n```",
                    level="Unknown",
                    raw_analysis={"raw_response": json_response}
                )

        except Exception as e:
            logger.error(f"Error detecting text level: {str(e)}")
            raise

    def _create_text_level_prompt(
    self,
    text: str,
    language: str,
     level_system: str) -> str:
        """Создает промпт для определения уровня текста"""

        # Определяем языковые параметры на основе указанного языка
        language_codes = {
            "english": {"code": "en", "native": "English"},
            "spanish": {"code": "es", "native": "Español"},
            "french": {"code": "fr", "native": "Français"},
            "german": {"code": "de", "native": "Deutsch"},
            "italian": {"code": "it", "native": "Italiano"},
            "chinese": {"code": "zh", "native": "中文"},
            "japanese": {"code": "ja", "native": "日本語"},
            "korean": {"code": "ko", "native": "한국어"},
            "turkish": {"code": "tr", "native": "Türkçe"},
            "russian": {"code": "ru", "native": "Русский"},
            "arabic": {"code": "ar", "native": "العربية"}
        }

        language_info = language_codes.get(
    language.lower(), {
        "code": "en", "native": "English"})
        language_code = language_info["code"]
        language_native = language_info["native"]

        # Определяем критерии оценки уровня для разных систем
        if "CEFR" in level_system:
            level_criteria = """
- A1 (Beginner): Can understand and use familiar everyday expressions and very basic phrases. Can introduce him/herself and others.
- A2 (Elementary): Can understand sentences and frequently used expressions related to areas of most immediate relevance.
- B1 (Intermediate): Can deal with most situations likely to arise while traveling in an area where the language is spoken.
- B2 (Upper Intermediate): Can interact with a degree of fluency and spontaneity that makes regular interaction with native speakers quite possible.
- C1 (Advanced): Can express ideas fluently and spontaneously without much obvious searching for expressions.
- C2 (Proficiency): Can understand with ease virtually everything heard or read. Can express him/herself spontaneously, very fluently and precisely.
"""
            valid_levels = ["A1", "A2", "B1", "B2", "C1", "C2"]
        elif "HSK" in level_system:
            level_criteria = """
- HSK 1: Can understand and use very simple Chinese phrases.
- HSK 2: Can communicate in simple and routine tasks requiring a simple and direct exchange of information.
- HSK 3: Can handle most situations likely to arise whilst traveling in Chinese-speaking regions.
- HSK 4: Can interact with a degree of fluency and spontaneity with Chinese speakers.
- HSK 5: Can express ideas fluently without much difficulty with native Chinese speakers.
- HSK 6: Can express themselves fluently and precisely in complex situations in Chinese.
"""
            valid_levels = ["HSK1", "HSK2", "HSK3", "HSK4", "HSK5", "HSK6"]
        elif "JLPT" in level_system:
            level_criteria = """
- N5: Can understand basic Japanese.
- N4: Can understand basic Japanese used in daily situations to a certain degree.
- N3: Can understand Japanese used in everyday situations to a certain degree.
- N2: Can understand Japanese used in everyday situations and in a variety of circumstances.
- N1: Can understand Japanese used in a wide range of circumstances.
"""
            valid_levels = ["N5", "N4", "N3", "N2", "N1"]
        elif "TOPIK" in level_system:
            level_criteria = """
- TOPIK 1: Can understand and use familiar everyday expressions in Korean.
- TOPIK 2: Can communicate in simple and routine tasks in Korean.
- TOPIK 3: Can handle most situations in Korean.
- TOPIK 4: Can express ideas with fluency in Korean.
- TOPIK 5: Can express ideas with high fluency in Korean.
- TOPIK 6: Can express ideas with native-like fluency in Korean.
"""
            valid_levels = [
    "TOPIK1",
    "TOPIK2",
    "TOPIK3",
    "TOPIK4",
    "TOPIK5",
     "TOPIK6"]
        elif "ТРКИ" in level_system:
            level_criteria = """
- ТЭУ (A1): Базовое владение русским языком для минимального общения.
- ТБУ (A2): Базовый уровень владения для ограниченного повседневного общения.
- ТРКИ-1 (B1): Средний уровень для достаточного общения в бытовой и социально-культурной сферах.
- ТРКИ-2 (B2): Уровень, необходимый для обучения и работы по нелингвистическим специальностям.
- ТРКИ-3 (C1): Уровень, достаточный для профессиональной деятельности на русском языке.
- ТРКИ-4 (C2): Свободное владение русским языком близкое к уровню носителя языка.
"""
            valid_levels = [
    "ТЭУ",
    "ТБУ",
    "ТРКИ-1",
    "ТРКИ-2",
    "ТРКИ-3",
     "ТРКИ-4"]
            else:
                level_criteria = """
- Beginner: Can understand and use very basic phrases.
- Elementary: Can communicate in simple and routine tasks.
- Intermediate: Can handle most situations in everyday life.
- Upper Intermediate: Can interact with a degree of fluency.
- Advanced: Can express ideas fluently and spontaneously.
- Proficient: Can understand virtually everything heard or read.
"""
                valid_levels = [
                    "Beginner",
                    "Elementary",
                    "Intermediate",
                    "Upper Intermediate",
                    "Advanced",
                    "Proficient"]

        # Формируем промпт для определения уровня текста
        prompt = f"""
# TASK: ANALYZE TEXT LEVEL

# CONTEXT:
I need a detailed analysis of the level of a text in {language_native}.
The text contains approximately {len(text.split())} words.
Please use the {level_system} scale for your analysis.

# LEVEL CRITERIA:
{level_criteria}

# OUTPUT REQUIREMENTS:
1. You MUST return your analysis as a JSON object with the following fields:
   - "level": The exact level from {valid_levels}
   - "explanation": Detailed explanation in {language_native} why you determined this level
   - "vocabulary_analysis": Assessment of vocabulary level
   - "grammar_analysis": Assessment of grammar complexity
   - "sentence_structure": Assessment of sentence complexity
   - "recommendations": Suggestions for readers at different levels

2. The "level" field MUST be exactly one of these values: {valid_levels}
3. Do not include any text before or after the JSON object
4. Make sure the JSON is properly formatted and can be parsed

# IMPORTANT LANGUAGE INSTRUCTION:
- The explanation and all analysis fields MUST be written in {language_native} language ({language_code})
- Only the JSON field names should be in English
- DO NOT translate your analysis into any other language
- Use ONLY {language_native} for all content values

# THE TEXT TO ANALYZE:
{text}

Now analyze this text and determine its language level according to the {level_system} scale.
Return ONLY a well-formatted JSON object as specified.
"""

        return prompt

    @memory_optimized()
    async def change_text_level(
        self,
        text: str,
        language: str,
        target_level: str,
        preserve_style: bool = True,
        **kwargs
    ) -> str:
        """
        Изменение уровня сложности текста

        Args:
            text (str): Исходный текст
            language (str): Язык текста
            target_level (str): Целевой уровень (A1, A2, B1, B2, C1, C2, ...)
            preserve_style (bool): Сохранять ли оригинальный стиль текста
            **kwargs: Дополнительные параметры

        Returns:
            str: Адаптированный текст
        """
        try:
            user_id = kwargs.get('user_id', 1)

            logger.info(f"Changing text level to {target_level} for {language} text (preserve_style={preserve_style})")

            # Создаем данные для промпта
            prompt_data = {
                'text_content': text,
                'language': language,
                'target_level': target_level,
                'preserve_style': preserve_style
            }

            # Используем функцию форматирования промпта из api/v1/content.py
            # Но так как она находится в другом модуле, создаем промпт
            # непосредственно здесь

            # Инструкции для сохранения стиля
            preserve_style_instructions = ""
            if preserve_style:
                preserve_style_instructions = """
                IMPORTANT: Preserve the original style, tone, and structure of the text as much as possible.
                Keep the same paragraph structure, sentence patterns, and stylistic elements.
                Only change what is necessary to adjust the language level.
                """
            else:
                preserve_style_instructions = """
                You may restructure the text as needed to match the target level.
                Feel free to change sentence structures, vocabulary, and organization to best fit the target level.
                """

            # Форматирование инструкций
            lesson_format_instructions = """
            Format your response as clean text without headings or explanations.
            Only provide the adapted text - do not include any prompts, disclaimers, or instructions.
            Do not mention the changes you made or explain your process.
            """

            # Инструкции для конкретных уровней языка
            level_specific_instructions = ""

            # Определяем систему уровней на основе языка
            if language.lower() in [
    "english",
    "french",
    "spanish",
    "german",
    "italian",
    "portuguese",
    "dutch",
    "swedish",
    "finnish",
    "danish",
    "norwegian",
     "turkish"]:
                # CEFR уровни для европейских языков
                if target_level.upper() in ["C1", "C2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (CEFR - Advanced/Proficient):
                    - Use sophisticated academic and specialized vocabulary
                    - Incorporate complex grammatical structures (passive voice, subjunctive mood, inversion, etc.)
                    - Include complex sentence structures with multiple dependent clauses
                    - Employ advanced cohesive devices and discourse markers
                    - Use nuanced expressions and precise terminology
                    - Incorporate idiomatic expressions and metaphoric language where appropriate
                    - Utilize a formal academic/professional tone throughout
                    - Demonstrate mastery of complex syntactical patterns
                    - Include specialized terminology relevant to the subject matter

                    The output should reflect the language proficiency of a highly educated native speaker or academic professional.
                    """
                elif target_level.upper() in ["B1", "B2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (CEFR - Intermediate):
                    - Use intermediate vocabulary appropriate for regular conversations and some specific topics
                    - Include a mix of simple and compound sentences
                    - Use common idioms and expressions where appropriate
                    - Employ a semi-formal tone suitable for general audiences
                    - Include some cohesive devices to link ideas
                    """
                elif target_level.upper() in ["A1", "A2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (CEFR - Elementary):
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short and simple with basic grammatical structures
                    - Avoid idioms, phrasal verbs, and complex expressions
                    - Repeat key vocabulary to reinforce comprehension
                    - Use very clear and concrete language
                    """
            elif language.lower() == "chinese":
                # HSK уровни для китайского языка
                if target_level.lower() in ["hsk6", "hsk7-9"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Advanced Chinese):
                    - Use sophisticated vocabulary including literary and formal expressions
                    - Incorporate complex grammatical structures and patterns
                    - Include varied sentence structures with multiple clauses
                    - Use advanced chengyu (四字成语) where appropriate
                    - Employ formal academic language for specific topics
                    - Use nuanced expressions and precise terminology
                    """
                elif target_level.lower() in ["hsk3", "hsk4", "hsk5"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Intermediate Chinese):
                    - Use vocabulary for daily topics and some specialized areas
                    - Include both simple and moderately complex sentences
                    - Use common chengyu (四字成语) where appropriate
                    - Maintain clear paragraph structure and logical flow
                    - Use appropriate connectors for coherence
                    """
                elif target_level.lower() in ["hsk1", "hsk2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Elementary Chinese):
                    - Use only basic, high-frequency vocabulary (around 300-600 words)
                    - Keep sentences short and simple with basic structures
                    - Avoid complex grammar patterns and idioms
                    - Use simple sentence patterns with basic subject-verb-object structure
                    - Repeat key vocabulary to reinforce comprehension
                    """
            elif language.lower() == "japanese":
                # JLPT уровни для японского языка
                if target_level.lower() in ["n1", "n2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Advanced Japanese):
                    - Use sophisticated vocabulary including keigo (敬語) and specialized terminology
                    - Incorporate complex grammatical structures and patterns
                    - Use kanji appropriate for N1-N2 level (1000+ kanji)
                    - Include varied sentence structures with multiple clauses
                    - Use appropriate formal/informal expressions based on context
                    - Employ specialized vocabulary for academic/professional topics
                    """
                elif target_level.lower() in ["n3"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Intermediate Japanese):
                    - Use vocabulary for daily topics and some specialized areas
                    - Include both simple and moderately complex sentences
                    - Use kanji appropriate for N3 level (600+ kanji)
                    - Maintain clear paragraph structure with appropriate particles
                    - Use some common idiomatic expressions
                    """
                elif target_level.lower() in ["n4", "n5"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Elementary Japanese):
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short with simple structures
                    - Use limited kanji (around 100-300 kanji) with furigana support
                    - Focus on basic particles and verb conjugations
                    - Use simple polite forms (-masu, -desu)
                    """
            elif language.lower() == "korean":
                # TOPIK уровни для корейского языка
                if target_level.lower() in ["topik5", "topik6"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Advanced Korean):
                    - Use sophisticated vocabulary including honorific and humble forms
                    - Incorporate complex grammatical structures and patterns
                    - Include varied sentence structures with multiple clauses
                    - Use advanced idiomatic expressions and proverbs
                    - Employ sophisticated connectors and discourse markers
                    - Use formal/academic language appropriate for professional contexts
                    """
                elif target_level.lower() in ["topik3", "topik4"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Intermediate Korean):
                    - Use vocabulary for daily topics and some specialized areas
                    - Include both simple and compound sentences
                    - Use appropriate honorific forms based on context
                    - Maintain clear paragraph structure with logical flow
                    - Use common idiomatic expressions where appropriate
                    """
                elif target_level.lower() in ["topik1", "topik2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Elementary Korean):
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short with simple structures
                    - Focus on basic particles and verb conjugations
                    - Use simple polite forms (-요/습니다)
                    - Avoid complex grammar patterns and idioms
                    """
            elif language.lower() == "arabic":
                # Уровни для арабского языка
                if target_level.lower() in ["advanced", "superior", "native"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Advanced Arabic):
                    - Use sophisticated MSA (Modern Standard Arabic) vocabulary and expressions
                    - Incorporate complex grammatical structures including proper case endings
                    - Include varied sentence structures with sophisticated connectors
                    - Use advanced idiomatic expressions where appropriate
                    - Employ formal/academic language appropriate for literary or media contexts
                    - Use precise terminology for specialized topics
                    """
                elif target_level.lower() in ["intermediate"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Intermediate Arabic):
                    - Use vocabulary for daily topics and general concepts
                    - Include both simple and compound sentences
                    - Use appropriate grammatical structures with attention to gender/number agreement
                    - Maintain clear paragraph structure with logical flow
                    - Use common idiomatic expressions where appropriate
                    """
                elif target_level.lower() in ["beginner", "elementary"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Elementary Arabic):
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short with simple structures
                    - Focus on basic grammar patterns and verb conjugations
                    - Use simple nominal and verbal sentences
                    - Avoid complex constructions and case endings
                    """
            elif language.lower() == "russian":
                # TORFL уровни для русского языка
                if target_level.lower() in ["t3", "t4"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Advanced Russian - ТРКИ-III/IV):
                    - Use sophisticated vocabulary including literary and formal expressions
                    - Incorporate complex grammatical structures with correct aspect and case usage
                    - Include varied sentence structures with multiple clauses and participles
                    - Use advanced idiomatic expressions and phraseology
                    - Employ stylistically appropriate language for different registers
                    - Use precise terminology for specialized academic/professional topics
                    """
                elif target_level.lower() in ["t1", "t2"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Intermediate Russian - ТРКИ-I/II):
                    - Use vocabulary for daily topics and some specialized areas
                    - Include both simple and compound sentences with proper case and aspect
                    - Use appropriate verbal prefixes and motion verbs
                    - Maintain clear paragraph structure with logical connectors
                    - Use common idioms and expressions where appropriate
                    """
                elif target_level.lower() in ["tea", "tba"]:
                    level_specific_instructions = f"""
                    For {target_level} level (Elementary Russian - ТЭУ/ТБУ):
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short with simple structures
                    - Focus on basic case usage and verb conjugations
                    - Use simple imperfective/perfective verb forms
                    - Avoid complex syntax and idioms
                    """
            else:
                # По умолчанию используем CEFR уровни для других языков
                if target_level.upper() in ["C1", "C2"]:
                    level_specific_instructions = f"""
                    For {target_level} level:
                    - Use sophisticated academic and specialized vocabulary
                    - Incorporate complex grammatical structures
                    - Include complex sentence structures with multiple dependent clauses
                    - Employ advanced cohesive devices and discourse markers
                    - Use nuanced expressions and precise terminology
                    """
                elif target_level.upper() in ["B1", "B2"]:
                    level_specific_instructions = f"""
                    For {target_level} level:
                    - Use intermediate vocabulary appropriate for regular conversations
                    - Include a mix of simple and compound sentences
                    - Use common expressions where appropriate
                    - Employ a semi-formal tone suitable for general audiences
                    """
                elif target_level.upper() in ["A1", "A2"]:
                    level_specific_instructions = f"""
                    For {target_level} level:
                    - Use only basic, high-frequency vocabulary
                    - Keep sentences short and simple with basic structures
                    - Avoid idioms and complex expressions
                    - Use very clear and concrete language
                    """

            # Инструкции для стилей текста
            style_instructions = ""
            if "academic" in kwargs.get(
    'vocabulary',
    '').lower() or "academic" in kwargs.get(
        'style',
         '').lower():
                style_instructions = """
                Style Instructions for Academic Text:
                - Use formal academic language and specialized terminology
                - Avoid contractions, colloquialisms, and personal pronouns (I, we)
                - Employ passive voice and impersonal constructions where appropriate
                - Use precise terminology and objective language
                - Include citations or references to theoretical concepts where relevant
                - Maintain a detached, analytical tone throughout
                """
            elif "business" in kwargs.get('vocabulary', '').lower() or "business" in kwargs.get('style', '').lower():
                style_instructions = """
                Style Instructions for Business/Professional Text:
                - Use professional business terminology and formal language
                - Include industry-specific vocabulary where appropriate
                - Employ clear, direct language with precise phrasing
                - Use diplomatic and persuasive language techniques
                - Maintain a confident, authoritative tone
                - Focus on action-oriented and results-driven language
                """

            prompt = f"""
            {lesson_format_instructions}

            Please adapt the following text to {target_level} level of {language}.

            {preserve_style_instructions}

            {level_specific_instructions}

            {style_instructions}

            When adapting the text:
            1. Adjust vocabulary complexity to match the target level
            2. Modify sentence structures as appropriate for the level
            3. Maintain the original meaning and key information
            4. Ensure the text remains coherent and natural
            5. Do not shorten or summarize the text - maintain approximately the same length
            6. Do not simplify the content if upgrading to a higher level

            Original text:
            {text}

            {lesson_format_instructions}
            """

            # Генерируем адаптированный текст
            adapted_text = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={
    "action": "change_text_level",
     "target_level": target_level}
            )

            logger.info(f"Generated adapted text (length: {
        len(adapted_text)})")
            return adapted_text

        except Exception as e:
            logger.error(f"Error changing text level: {str(e)}")
            raise

    @memory_optimized()
    async def regenerate_text(
        self,
        text: str,
        language: str,
        vocabulary_type: str = "neutral",
        preserve_style: bool = True,
        **kwargs
    ) -> str:
        """
        Перегенерация текста с изменением типа лексики

        Args:
            text (str): Исходный текст
            language (str): Язык текста
            vocabulary_type (str): Тип лексики (formal, informal, neutral, academic, slang)
            preserve_style (bool): Сохранять ли оригинальный стиль текста
            **kwargs: Дополнительные параметры

        Returns:
            str: Перегенерированный текст
        """
        try:
            user_id = kwargs.get('user_id', 1)

            logger.info(f"Regenerating text with vocabulary type '{vocabulary_type}' for {language} text (preserve_style={preserve_style})")

            # Инструкции для сохранения стиля
            preserve_style_instructions = ""
            if preserve_style:
                preserve_style_instructions = """
                IMPORTANT: Preserve the original style, tone, and structure of the text as much as possible.
                Keep the same paragraph structure, sentence patterns, and organization.
                Only change words and expressions to match the target vocabulary type.
                """
            else:
                preserve_style_instructions = """
                You may restructure the text as needed to match the target vocabulary type.
                Feel free to change sentence structures, organization, and word choice.
                """

            # Инструкции для типа лексики
            vocabulary_instructions = ""
            if vocabulary_type == "formal":
                vocabulary_instructions = """
                Use FORMAL vocabulary and expressions:
                - Avoid contractions (use "cannot" instead of "can't")
                - Use sophisticated vocabulary where appropriate
                - Prefer longer, more complex sentences
                - Avoid colloquialisms and idioms
                - Use passive voice where appropriate
                - Maintain a professional, respectful tone
                """
            elif vocabulary_type == "informal":
                vocabulary_instructions = """
                Use INFORMAL vocabulary and expressions:
                - Use contractions (e.g., "can't" instead of "cannot")
                - Use common, everyday vocabulary
                - Use shorter, simpler sentences
                - Include some colloquial expressions and idioms
                - Prefer active voice
                - Maintain a friendly, conversational tone
                """
            elif vocabulary_type == "academic":
                vocabulary_instructions = """
                Use ACADEMIC vocabulary and expressions:
                - Use field-specific terminology and scholarly language
                - Employ precise, technical vocabulary and formal academic expressions
                - Use complex sentence structures with multiple dependent clauses
                - Maintain an objective, analytical tone throughout
                - Use sophisticated transitional phrases to connect ideas
                - Avoid personal pronouns and maintain academic distance
                - Include nominalizations (using nouns instead of verbs where possible)
                - Employ passive constructions where appropriate
                - Use proper citations and references when mentioning theories or concepts
                - Include specialized terminology relevant to the subject matter
                - Demonstrate mastery of complex syntactical patterns

                The output should reflect the language of scholarly articles and academic papers.
                """
            elif vocabulary_type == "business":
                vocabulary_instructions = """
                Use BUSINESS/PROFESSIONAL vocabulary and expressions:
                - Use professional business terminology and industry-specific vocabulary
                - Employ formal language with precise, concise phrasing
                - Include business jargon and industry terms where appropriate
                - Use diplomatic and persuasive language techniques
                - Maintain a confident, authoritative tone
                - Focus on action-oriented and results-driven language
                - Use professional greetings and closings if relevant
                - Include relevant business concepts and frameworks
                - Employ strategic and analytical language
                - Balance between accessibility and professional terminology
                """
            elif vocabulary_type == "slang":
                vocabulary_instructions = """
                Use modern SLANG and casual expressions:
                - Include contemporary slang terms where appropriate
                - Use very informal vocabulary and expressions
                - Use shorter sentences and fragments
                - Include conversational fillers (well, you know, like)
                - Maintain a very casual, friendly tone
                - Use first and second person perspectives
                """
            else:  # neutral
                vocabulary_instructions = """
                Use NEUTRAL vocabulary and expressions:
                - Balance between formal and informal language
                - Use common vocabulary with some sophisticated terms
                - Vary sentence length and complexity
                - Minimize slang or highly technical terminology
                - Maintain a balanced, accessible tone
                """

            # Форматирование инструкций
            lesson_format_instructions = """
            Format your response as clean text without headings or explanations.
            Only provide the regenerated text - do not include any prompts, disclaimers, or instructions.
            Do not mention the changes you made or explain your process.
            """

            prompt = f"""
            {lesson_format_instructions}

            Please regenerate the following text in {language} using {vocabulary_type.upper()} vocabulary and expressions.

            {preserve_style_instructions}

            {vocabulary_instructions}

            When regenerating the text:
            1. Change vocabulary and expressions to match the target style
            2. Maintain the original meaning and key information
            3. Ensure the text remains coherent and natural
            4. Do not shorten or summarize the text - maintain approximately the same length
            5. Preserve the original tone while adapting to the requested vocabulary type

            Original text:
            {text}

            {lesson_format_instructions}
            """

            # Генерируем перегенерированный текст
            regenerated_text = await self.generate_content(
                content_type=ContentType.TEXT_ANALYSIS,
                prompt=prompt,
                user_id=user_id,
                extra_params={
    "action": "regenerate_text",
     "vocabulary_type": vocabulary_type}
            )

            logger.info(f"Generated regenerated text (length: {
        len(regenerated_text)})")
            return regenerated_text

        except Exception as e:
            logger.error(f"Error regenerating text: {str(e)}")
            raise

    async def generate_course_structure(
        self, prompt: Dict[str, Any], request: Request = None) -> Dict[str, Any]:
        """
        Генерирует структуру курса на основе промпта

        Args:
            prompt: Промпт и необходимые данные
            request: Объект запроса FastAPI

        Returns:
            Dict[str, Any]: Сгенерированная структура курса
        """
        try:
            # Очищаем кеш перед генерацией, чтобы избежать использования старых
            # данных
            await self._clear_cache_before_generation()

            # Извлекаем данные из запроса и форматируем промпт
            context = prompt.get('context', {})
            course_context = {
                "course_name": context.get('course_name', 'Новый курс'),
                "language": context.get('language', 'english'),
                "level": context.get('level', 'beginner'),
                "target_audience": context.get('target_audience', 'adults'),
                "format": context.get('format', 'online')
            }

            # Форматируем промпт для обогащения структуры курса
            formatted_prompt = """
            Ты - опытный методист по преподаванию языков с большим опытом создания учебных программ.

            # ЗАДАЧА
            Создать структурированный языковой курс для изучения языка с четко определенными уроками.

            # ВАЖНЫЕ ИНСТРУКЦИИ ПО ФОРМАТУ ОТВЕТА
            1. Ответ должен быть ТОЛЬКО В ФОРМАТЕ JSON
            2. НЕ ИСПОЛЬЗУЙ разметку markdown (```) или другие обозначения кода
            3. Ответ должен начинаться с символа {{ и заканчиваться символом }}
            4. Ответ должен быть ОДНИМ JSON-объектом с полем "lessons", содержащим массив уроков
            5. Используй ДВОЙНЫЕ кавычки для ключей и строковых значений
            6. Убедись, что твой JSON валиден и может быть спарсен стандартной функцией JSON.parse()
            7. Не добавляй комментарии, объяснения или дополнительный текст до или после JSON
            8. НЕ ИСПОЛЬЗУЙ сокращения вида "// ... продолжить уроки" - создай все уроки полностью
            9. НЕ ИСПОЛЬЗУЙ сокращения вида "// и так далее" вместо полного содержимого
            10. СОЗДАЙ ВСЕ УРОКИ ПОЛНОСТЬЮ - никаких заглушек или схематичных уроков
            11. НИКОГДА не используй комментарии или сокращения вида "// Continue with lessons 2-12" - ЭТО ОШИБКА!
            12. НЕ используй комментарии JavaScript // внутри JSON - они не допустимы и ломают формат!

            # ТОЧНАЯ СТРУКТУРА ОТВЕТА
            {{
              "name": "Название курса",
              "description": "Подробное описание курса",
              "lessons": [
                {{
                  "title": "Урок 1: Название урока",
                  "description": "Подробное описание этого урока",
                  "objectives": ["Цель 1", "Цель 2", "Цель 3"],
                  "grammar": ["Грамматика 1", "Грамматика 2"],
                  "vocabulary": ["Лексика 1", "Лексика 2", "Лексика 3"],
                  "duration": 60,
                  "activities": [
                    {{
                      "name": "Название активности",
                      "type": "warm-up",
                      "duration": 15,
                      "description": "Описание активности",
                      "materials": ["Материал 1", "Материал 2"]
                    }}
                  ],
                  "materials": ["Учебник", "Рабочие листы"],
                  "homework": {{
                    "description": "Краткое описание домашнего задания",
                    "tasks": ["Повторение изученного материала", "Выполнение практических заданий"],
                    "estimatedTime": 30
                  }}
                }},
                {{
                  "title": "Урок 2: Название урока",
                  "description": "Подробное описание этого урока",
                  "objectives": ["Цель 1", "Цель 2", "Цель 3"],
                  "grammar": ["Грамматика 1", "Грамматика 2"],
                  "vocabulary": ["Лексика 1", "Лексика 2", "Лексика 3"],
                  "duration": 60,
                  "activities": [
                    {{
                      "name": "Название активности",
                      "type": "warm-up",
                      "duration": 15,
                      "description": "Описание активности",
                      "materials": ["Материал 1", "Материал 2"]
                    }}
                  ],
                  "materials": ["Учебник", "Рабочие листы"],
                  "homework": {{
                    "description": "Краткое описание домашнего задания",
                    "tasks": ["Повторение изученного материала", "Выполнение практических заданий"],
                    "estimatedTime": 30
                  }}
                }}
              ]
            }}

            # ВАЖНЫЕ ТРЕБОВАНИЯ К СОДЕРЖАНИЮ
            1. Создай курс "{course_name}" на языке {language} для уровня {level}
            2. Начальный уровень студента: {start_level}
            3. Целевая аудитория курса: {target_audience}
            4. Формат обучения: {format}
            5. Методика обучения: {methodology}

            # ОБЯЗАТЕЛЬНЫЕ ПОЛЯ ДЛЯ КАЖДОГО УРОКА (СТРОГО СЛЕДУЙ ЭТОЙ
            # СТРУКТУРЕ)
            1. "title" (строка): Информативное название урока, включающее его номер
            2. "description" (строка): Детальное описание урока (не менее 30 слов) - ОБЯЗАТЕЛЬНОЕ ПОЛЕ!
            3. "objectives" (массив строк): 3-5 конкретных целей обучения
            4. "grammar" (массив строк): 2-5 грамматических тем урока
            5. "vocabulary" (массив строк): 5-15 лексических единиц или тематических групп
            6. "duration" (число): Продолжительность урока в минутах (от 30 до 120) - ДОЛЖНО БЫТЬ ПОЛОЖИТЕЛЬНЫМ ЧИСЛОМ!
            7. "activities" (массив объектов): 3-7 учебных активностей с указанием типа, продолжительности и описания
            8. "materials" (массив строк): Список учебных материалов
            9. "homework" (объект с полями): Структурированное домашнее задание - ДОЛЖНО БЫТЬ ОБЪЕКТОМ, А НЕ МАССИВОМ ИЛИ СТРОКОЙ!
               - "description" (строка): Краткое описание домашнего задания
               - "tasks" (массив строк): Список конкретных заданий
               - "estimatedTime" (число): Оценочное время выполнения в минутах - ДОЛЖНО БЫТЬ ПОЛОЖИТЕЛЬНЫМ ЧИСЛОМ!

            # СТРОГАЯ ПРОВЕРКА ПЕРЕД ОТВЕТОМ
            - Убедись, что каждое поле соответствует указанному типу данных (строка, массив, объект, число)
            - Проверь наличие ВСЕХ обязательных полей для каждого урока
            - Убедись, что каждый урок содержит поле "description" с детальным описанием урока!
            - Убедись, что поле "homework" является ОБЪЕКТОМ с полями "description", "tasks" и "estimatedTime"!
            - Проверь, что поле "duration" содержит ПОЛОЖИТЕЛЬНОЕ ЧИСЛО (например, 60 минут)!
            - Убедись, что твой JSON не содержит синтаксических ошибок
            - Проверь, что ты НЕ использовал сокращения или комментарии, а создал все уроки полностью!
            - Убедись, что в JSON нет сокращений типа "// continue with lessons" - создай все уроки!
            - JSON должен быть ПОЛНОСТЬЮ валидным, с корректными запятыми между элементами!
            - Ты ОБЯЗАТЕЛЬНО должен создать все {lessons_count} уроков ПОЛНОСТЬЮ!
            - Обязательно проверь, что каждое поле типа число (duration, estimatedTime) имеет положительное значение!

            # ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ
            - Создай курс c {lessons_count} уроками ПОЛНОСТЬЮ, без сокращений
            - Продолжительность каждого занятия: примерно {lesson_duration} минут
            - Учитывай возраст студента: {student_age}
            - Интересы студента: {student_interests}
            - Цели обучения: {student_goals}
            - Типичные ошибки студента: {common_mistakes}

            # ВАЖНОЕ ПРЕДУПРЕЖДЕНИЕ
            Если ты создашь неполный курс или будешь использовать сокращения вместо полных уроков, запрос будет считаться неудачным.
            Создай все уроки полностью, с полным описанием для каждого урока!

            # ПОВТОРНОЕ СТРОГОЕ НАПОМИНАНИЕ О ФОРМАТЕ ОТВЕТА
            - НИКОГДА не используй комментарии в JSON формате типа "// continue with lessons 2-12"!
            - В JSON ЗАПРЕЩЕНЫ комментарии вида "//", они нарушают синтаксис и делают JSON невалидным!
            - Создай ВСЕ {lessons_count} уроков полностью, не сокращай! Лучше создай меньше, но полноценных уроков.
            - Ответ должен быть ОДНИМ ПОЛНЫМ валидным JSON объектом без синтаксических ошибок!
            """

            # Заполняем значения в шаблоне
            formatted_prompt = formatted_prompt.format(
                course_name=context.get('course_name', 'Новый курс'),
                language=context.get('language', 'english'),
                level=context.get('level', 'beginner'),
                start_level=context.get(
    'start_level', context.get(
        'level', 'beginner')),
                target_audience=context.get('target_audience', 'adults'),
                format=context.get('format', 'online'),
                methodology=context.get('methodology', 'communicative'),
                # Ограничиваем количество уроков для снижения нагрузки
                lessons_count=min(context.get('lessons_count', 12), 7),
                lesson_duration=context.get('lesson_duration', 60),
                student_age=context.get('student_age', 'взрослый'),
                student_interests=context.get(
    'student_interests', 'общие темы'),
                student_goals=context.get(
    'student_goals', 'повышение общего уровня языка'),
                common_mistakes=context.get(
    'common_mistakes', 'типичные для данного уровня')
            )

            # Генерируем контент с настройками для структурированного JSON
            try:
                logger.info("Начинаем генерацию структуры курса")

                # Генерируем контент с использованием подготовленного промпта
                content = await self._generate_with_g4f(formatted_prompt, ContentType.COURSE_STRUCTURE)

                # Если не удалось сгенерировать с помощью g4f, пробуем с
                # очередью
                if not content and request:
                    logger.info("Переключение на генерацию через очередь")
                    user_id = 1  # Дефолтный user_id
                    try:
                        if hasattr(
    request, 'user') and hasattr(
        request.user, 'id'):
                            user_id = request.user.id
                    except Exception as e:
                        logger.warning(
    f"Не удалось получить user_id из запроса: {
        str(e)}")

                    content = await self._generate_with_queue(user_id, formatted_prompt, ContentType.COURSE_STRUCTURE)

                # Если все еще нет результата, используем запасную структуру
                if not content:
                    logger.warning(
                        "Не удалось сгенерировать содержимое, используем запасную структуру")
                    return self._generate_fallback_structure(prompt)

                # Логгируем превью ответа для отладки
                preview_length = min(500, len(content))
                logger.info(f"Получен ответ от нейросети длиной {len(content)} символов. Превью: {content[:preview_length]}...")

                # Сохраняем полный ответ в лог с разделителями для облегчения
                # поиска
                logger.info(f"НАЧАЛО ПОЛНОГО ОТВЕТА НЕЙРОСЕТИ ======================================")
                logger.info(f"{content}")
                logger.info(f"КОНЕЦ ПОЛНОГО ОТВЕТА НЕЙРОСЕТИ ======================================")

                # Очищаем JSON от маркдауна и других обрамлений
                cleaned_content = self._clean_json_response(content)
                logger.info(f"ОЧИЩЕННЫЙ КОНТЕНТ ОТ МАРКДАУНА: {cleaned_content[:200]}...")

                # Извлекаем JSON из контента, если он обернут в другой текст
                json_str = self._extract_json_from_content(cleaned_content)
                logger.info(f"ИЗВЛЕЧЕННЫЙ JSON: {json_str[:200]}...")

                # Парсим JSON с валидацией
                parsed_data = await self._parse_json_safely(json_str)

                # Если получили массив вместо объекта, преобразуем его в объект
                if isinstance(parsed_data, list) and len(parsed_data) > 0:
                    logger.warning(
                        "Преобразование массива объектов в словарь с уроками")
                    # Проверяем, если это массив уроков
                    if all(
    isinstance(
        item,
         dict) and 'title' in item for item in parsed_data):
                        course_desc = "Курс изучения {0} языка для {1} уровня {2}".format(
                            course_context['language'],
                            course_context['target_audience'],
                            course_context['level']
                        )
                        course_structure = {
                            "name": course_context['course_name'],
                            "description": course_desc,
                            "lessons": parsed_data
                        }
                        logger.info(f"Создан словарь из массива уроков, количество: {
        len(parsed_data)}")
                        return course_structure

                # Если не можем корректно преобразовать, возвращаем резервную
                # структуру
                if not isinstance(parsed_data, dict):
                    logger.error(
                        "Невозможно преобразовать ответ в корректную структуру курса")
                    return self._generate_fallback_structure(prompt)

                # Проверяем структуру курса
                if 'lessons' in parsed_data:
                    logger.info(f"В структуре курса найдено {len(parsed_data['lessons'])} уроков")

                    # Проверяем, что lessons это массив
                    if not isinstance(parsed_data['lessons'], list):
                        logger.warning(
    f"Поле lessons имеет неправильный тип: {
        type(
            parsed_data['lessons'])}")
                        parsed_data['lessons'] = []

                    # Обогащаем уроки дополнительными данными
                    enriched_lessons = []
                    for idx, lesson in enumerate(parsed_data['lessons']):
                        enriched_lessons.append(
    self._enrich_lesson_data(
        lesson, idx + 1))

                    # Создаем базовый словарь с обогащенным массивом уроков в
                    # поле lessons
                    course_description = "Курс изучения {0}".format(
                        prompt['context'].get('language', 'языка')
                    )
                    course_structure = {
                        "name": prompt['context'].get('course_name', 'Новый курс'),
                        "description": prompt['context'].get('description', course_description),
                        "language": prompt['context'].get('language', 'english'),
                        "level": prompt['context'].get('level', 'elementary'),
                        "lessons": enriched_lessons if enriched_lessons else self._generate_default_lessons(prompt)
                    }
                    logger.info(f"Создан словарь с массивом в поле lessons, уроков: {len(course_structure['lessons'])}")
                        else:
                    # Если это не массив или пустой массив, используем запасную
                    # структуру
                    return self._generate_fallback_structure(prompt)

                # Проверяем наличие обязательных полей
                required_fields = ['name', 'description', 'lessons']
                for field in required_fields:
                    if field not in course_structure:
                        logger.warning(
    f"В структуре курса отсутствует обязательное поле: {field}")
                        course_structure[field] = self._generate_default_value(
                            field, prompt)

                # Проверка уроков
                if not isinstance(
    course_structure.get(
        'lessons',
        []),
        list) or len(
            course_structure.get(
                'lessons',
                 [])) == 0:
                    logger.warning("Отсутствуют уроки в структуре курса")
                    course_structure['lessons'] = self._generate_default_lessons(
                        prompt)

                logger.info(f"Структура курса успешно сгенерирована, содержит {
        len(
            course_structure.get(
                'lessons',
                 []))} уроков")
                return course_structure

            except ValueError as ve:
                logger.error(f"Ошибка в формате значения: {str(ve)}")
                # Добавляем детали ошибки для диагностики
                import traceback
                logger.error(f"Трассировка ошибки: {traceback.format_exc()}")
                return self._generate_fallback_structure(prompt)
            except Exception as gen_error:
                logger.error(
    f"Ошибка при генерации контента: {
        str(gen_error)}")
                # Добавляем детали ошибки для диагностики
                import traceback
                logger.error(f"Трассировка ошибки: {traceback.format_exc()}")
                return self._generate_fallback_structure(prompt)

        except Exception as e:
            logger.error(f"Общая ошибка генерации структуры курса: {str(e)}")
            # Добавляем детали ошибки для диагностики
            import traceback
            logger.error(f"Трассировка общей ошибки: {traceback.format_exc()}")
            # Вместо поднятия исключения, возвращаем базовую структуру
            return self._generate_fallback_structure(prompt)

    async def _clear_cache_before_generation(self):
        """
        Очищает кеш перед генерацией структуры курса для избежания использования старых данных
        """
        try:
            from ...core.cache import CacheService
            cache = CacheService()
            await cache.invalidate_pattern("course_structure:*")
            logger.info("Кеш структуры курса успешно очищен перед генерацией")
        except Exception as e:
            logger.warning(
    f"Не удалось очистить кеш перед генерацией: {
        str(e)}")

    def _enrich_lesson_data(self, lesson: dict, index: int) -> dict:
        """
        Обогащает данные урока недостающими полями.

        Args:
            lesson: Исходные данные урока
            index: Номер урока

        Returns:
            Обогащенный словарь урока с обязательными полями
        """
        # Создаем копию для изменения
        enriched = lesson.copy()

        # Обязательные поля для урока
        required_fields = {
            "title": "Урок {0}".format(index),
            "description": "Описание урока {0}".format(index),
            "objectives": [],
            "materials": [],
            "vocabulary": [],
            "grammar": [],
            "procedure": [],
            "homework": {
                "description": "Домашнее задание для урока {0}".format(index),
                "tasks": ["Выполнить упражнения по теме урока"],
                "estimatedTime": 30
            }
        }

        # Заполняем недостающие поля
        for field, default_value in required_fields.items():
            if field not in enriched or not enriched[field]:
                enriched[field] = default_value
                logger.info(
    "Добавлено недостающее поле '{0}' для урока {1}".format(
        field, index))

        # Если есть поля типа procedure, objectives и т.д., но они строки,
        # преобразуем их в списки
        fields_to_check = [
    "objectives",
    "materials",
    "vocabulary",
    "grammar",
     "procedure"]
        for field in fields_to_check:
            if field in enriched and isinstance(enriched[field], str):
                # Пытаемся разделить строку на абзацы или пункты
                parts = [part.strip()
                                    for part in enriched[field].split('\n') if part.strip()]
                if not parts:  # Если после разделения список пустой
                    # Используем всю строку как один элемент
                    parts = [enriched[field]]
                enriched[field] = parts
                logger.info(
    "Преобразовано поле '{0}' из строки в список для урока {1}".format(
        field, index))

        # КРИТИЧЕСКИ ВАЖНОЕ ИСПРАВЛЕНИЕ: гарантируем, что homework всегда будет
        # словарем в соответствии со схемой
        if "homework" in enriched:
            # Если homework не является словарем, преобразуем его
            if not isinstance(enriched["homework"], dict):
                # Сохраняем оригинальные задания
                original_homework = enriched["homework"]

                # Создаем правильную структуру словаря
                homework_dict = {
                    "description": f"Домашнее задание для урока {index}",
                    "tasks": [],
                    "estimatedTime": 30
                }

                # Преобразуем исходное значение в список задач
                if isinstance(original_homework, list):
                    # Если это уже список, используем его как tasks
                    homework_dict["tasks"] = [
    str(item) for item in original_homework]
                elif isinstance(original_homework, str):
                    # Если это строка, разбиваем ее на отдельные задания
                    items = [
    item.strip() for item in original_homework.split('\n') if item.strip()]
                    homework_dict["tasks"] = items if items else [
                        original_homework]
                    else:
                    # Если что-то совсем непонятное, создаем задание по
                    # умолчанию
                    homework_dict["tasks"] = [
                        "Выполнить упражнения по теме урока"]

                enriched["homework"] = homework_dict
                logger.info(f"Преобразовано поле \'homework\' в правильный формат словаря для урока {index}")
            else:
                # Проверяем наличие необходимых полей в уже существующем
                # словаре homework
                if "description" not in enriched["homework"] or not enriched["homework"]["description"]:
                    enriched["homework"]["description"] = f"Домашнее задание для урока {index}"
                if "tasks" not in enriched["homework"] or not enriched["homework"]["tasks"]:
                    enriched["homework"]["tasks"] = [
                        "Выполнить упражнения по теме урока"]

                # Гарантируем, что tasks - это список
                # Гарантируем, что tasks - это массив
                if not isinstance(enriched["homework"]["tasks"], list):
                    if isinstance(enriched["homework"]["tasks"], str):
                        enriched["homework"]["tasks"] = [
                            enriched["homework"]["tasks"]]
                        else:
                        enriched["homework"]["tasks"] = [
                            str(enriched["homework"]["tasks"])]

                # Гарантируем, что estimatedTime существует и положительный
            if "estimatedTime" not in enriched["homework"] or not isinstance(
    enriched["homework"]["estimatedTime"],
    (int,
     float)) or enriched["homework"]["estimatedTime"] <= 0:
                enriched["homework"]["estimatedTime"] = 30

        # Добавляем поле 'order' если его нет
        if 'order' not in enriched:
            enriched['order'] = index

        # Проверяем, что duration > 0
        if 'duration' not in enriched or not enriched['duration'] or enriched['duration'] <= 0:
            enriched['duration'] = 60  # Значение по умолчанию - 60 минут
            logger.info(
    "Установлено положительное значение продолжительности для урока {0}".format(index))

        return enriched

    def _clean_json_response(self, content: str) -> str:
        """
        Очищает ответ от форматированных блоков кода и других лишних элементов

        Args:
            content: Исходный контент

        Returns:
            str: Очищенный контент
        """
        # Логируем исходный контент
        logger.info(f"Исходный контент перед очисткой длиной {
        len(content)} символов")

        # Удаляем markdown-обозначения блоков кода
        content = re.sub(r'```(?:json)?\s*([\s\S]*?)\s*```', r'\1', content)

        # Удаляем комментарии типа // и строки с многоточием, используемые
        # нейросетью для обозначения продолжения
        # Удаляем однострочные комментарии типа //
        content = re.sub(r'//.*?(?:\n|$)', '\n', content)
        # Удаляем строки начинающиеся с //
        content = re.sub(r'(?m)^\s*//.*$', '', content)
        # Удаляем многострочные комментарии
        content = re.sub(r'/\*[\s\S]*?\*/', '', content)

        # Дополнительно удаляем строки с "... и так далее" или другие типичные
        # метакомментарии нейросети
        content = re.sub(r'(?m)^\s*(?://)?\s*\.\.\..*$', '',
                         content)  # Удаляем строки с "..."
                         else:
                         '', content)  # Удаляем "и так далее"
                             content = re.sub(
    r'(?m)^\s*(?://)?\s*continue with.*$',
    '',
    content,
     flags=re.IGNORECASE)  # Удаляем "continue with"

        # Удаляем вводные фразы типа "Вот структура курса в формате JSON:"
        content = re.sub(r'^.*?(?=\{)', '', content, flags=re.DOTALL)

        # Удаляем заключительный текст после последней закрывающей скобки JSON
        content = re.sub(r'(?<=\}).*$', '', content, flags=re.DOTALL)

        # Удаляем лишние пробелы и переносы строк в начале и конце
        content = content.strip()

        # Находим первую открывающую и последнюю закрывающую скобки JSON
        open_brace_idx = content.find('{')
        close_brace_idx = content.rfind('}')

        if open_brace_idx >= 0 and close_brace_idx > open_brace_idx:
            # Извлекаем только содержимое между первой открывающей и последней
            # закрывающей скобками
            content = content[open_brace_idx:close_brace_idx + 1]
            logger.info("Извлечен JSON между скобками: {0}:{1}, длина: {2}".format(
                open_brace_idx, close_brace_idx + 1, len(content)))

            # Проверяем, если это полный JSON
            try:
                json_obj = json.loads(content)
                if isinstance(json_obj, dict) and 'lessons' in json_obj:
                    logger.info(f"Получен полный JSON объект курса с {len(json_obj.get('lessons', []))} уроками")
                else:
                    logger.warning(
    f"Получен JSON, но без поля 'lessons': {
        list(
            json_obj.keys() if isinstance(
                json_obj,
                 dict) else [])}")
            except json.JSONDecodeError as e:
                logger.warning(
    f"Очищенный JSON не является валидным: {
        str(e)}")
                # Еще одна попытка очистки возможных ошибок
                try:
                    # Исправляем типичную проблему с запятыми в конце массивов
                    # и объектов
                    fixed_content = re.sub(r',(\s*[\]}])', r'\1', content)
                    # Удаляем все строки, которые выглядят как комментарии
                    fixed_content = re.sub(r'(?m)^\s*//.*$', '', fixed_content)
                    # Удаляем все символы, которые не являются частью валидного
                    # JSON
                    fixed_content = re.sub(
    r'[^\[\]{}":,.0-9a-zA-Z_\s-]', '', fixed_content)
                    json.loads(fixed_content)
                    logger.info(
                        "Успешно исправлен JSON после агрессивной очистки")
                    content = fixed_content
                except:
                    logger.warning(
                        "Не удалось исправить JSON даже после агрессивной очистки")

        return content

    def _extract_json_from_content(self, content: str) -> str:
        """
        Извлекает JSON-строку из контента

        Args:
            content: Исходный контент

        Returns:
            str: JSON-строка или пустая строка, если JSON не найден
        """
        logger.info(
    "Извлечение JSON из контента длиной {0} символов".format(
        len(content)))

        # Первоначальная проверка - проверяем, может ли контент уже быть
        # валидным JSON курса
        if content.strip().startswith('{') and content.strip().endswith('}'):
            try:
                parsed = json.loads(content)
                if isinstance(parsed, dict) and 'lessons' in parsed:
                    logger.info(f"Контент уже является валидным JSON курса с {len(parsed['lessons'])} уроками")
                    return content
            except json.JSONDecodeError as e:
                logger.debug(f"Контент не является валидным JSON: {str(e)}")

        # Сначала проверим, является ли весь контент валидным JSON
        content_stripped = content.strip()
        if (content_stripped.startswith('{') and content_stripped.endswith('}')) or \
           (content_stripped.startswith('[') and content_stripped.endswith(']')):
            try:
                # Пробуем разобрать весь контент как JSON
                json_obj = json.loads(content_stripped)

                # Проверяем, является ли это структурой курса
                if isinstance(json_obj, dict) and 'lessons' in json_obj:
                    logger.info(f"Весь контент является валидным JSON курса с {len(json_obj['lessons'])} уроками")
                    return content_stripped
                else:
                    logger.debug(
    f"Контент является валидным JSON, но не содержит уроки. Ключи: {
        list(
            json_obj.keys() if isinstance(
                json_obj,
                 dict) else [])}")
            except json.JSONDecodeError as e:
                logger.debug(
    f"Ошибка парсинга JSON: {
        str(e)} в позиции {
            e.pos}")
                # Пытаемся показать контекст вокруг ошибки
                if hasattr(e, 'pos') and e.pos is not None:
                    pos = e.pos
                    start = max(0, pos - 20)
                    end = min(len(content_stripped), pos + 20)
                    context = content_stripped[start:end]
                    logger.debug(f"Контекст ошибки: ...{context}...")

        # Ищем JSON в блоках кода
        json_block_pattern = r'```(?:json)?\s*([\s\S]*?)\s*```'
        json_blocks = re.findall(json_block_pattern, content)

        if json_blocks:
            # Проверяем все найденные блоки JSON на валидность
            for block in json_blocks:
                # Проверяем, начинается ли блок с { или [ и заканчивается } или
                # ]
                block_stripped = block.strip()
                if (block_stripped.startswith('{') and block_stripped.endswith('}')) or \
                   (block_stripped.startswith('[') and block_stripped.endswith(']')):
                    try:
                        # Пробуем разобрать JSON
                        parsed = json.loads(block_stripped)
                        # Проверяем, является ли это JSON-объектом курса
                        # (должен содержать lessons)
                        if isinstance(parsed, dict) and 'lessons' in parsed:
                            logger.info(f"Найдена структура курса в блоке кода длиной {
        len(block_stripped)} символов")
                            return block_stripped
                        # Или если это массив уроков
                        elif isinstance(parsed, list) and len(parsed) > 0 and \
                             all(isinstance(item, dict) and 'title' in item for item in parsed):
                            logger.info(f"Найден массив уроков в блоке кода длиной {
        len(block_stripped)} символов")
                            return block_stripped
                        else:
                            keys = list(
    parsed.keys()) if isinstance(
        parsed, dict) else "массив"
                            logger.debug(
    f"Блок JSON не содержит структуру курса. Ключи: {keys}")
                    except json.JSONDecodeError as e:
                        logger.debug(f"Ошибка парсинга блока: {str(e)}")

        # Добавляем логирование для первых и последних 50 символов контента
        if len(content) > 100:
            logger.info(f"Первые 50 символов контента: {content[:50]}")
            logger.info(f"Последние 50 символов контента: {content[-50:]}")

        # Пытаемся исправить возможно повреждённый JSON
        try:
            # Пробуем исправить кавычки и экранирование
            # Заменяем одинарные кавычки на двойные
            fixed_content = content.replace("'", '"')
            # Экранируем неэкранированные кавычки
            fixed_content = re.sub(r'(?<!\\)"', '\\"', fixed_content)
            fixed_content = re.sub(
    r'(?<!\\)\\(?!["\\])',
    '\\\\',
     fixed_content)  # Экранируем одиночные слеши

            # Пытаемся найти валидный JSON в исправленном контенте
            json_match = re.search(
    r'({[^{}]*({[^{}]*})*[^{}]*})', fixed_content)
            if json_match:
                potential_json = json_match.group(1)
                try:
                    parsed = json.loads(potential_json)
                    if isinstance(parsed, dict) and 'lessons' in parsed:
                        logger.info(f"Найден исправленный JSON курса длиной {
        len(potential_json)} символов")
                        return potential_json
                except json.JSONDecodeError:
                    pass
        except Exception as e:
            logger.debug(f"Ошибка при попытке исправить JSON: {str(e)}")

        # Ищем первую открывающую и последнюю закрывающую скобки для объекта
        start_idx = content.find('{')
        if start_idx >= 0:
            # Ищем соответствующую закрывающую скобку
            bracket_level = 0
            json_end = -1
            in_string = False
            escape_next = False

            for i in range(start_idx, len(content)):
                char = content[i]

                if escape_next:
                    escape_next = False
                    continue

                if char == '\\':
                    escape_next = True
                elif char == '"' and not escape_next:
                    in_string = not in_string
                elif not in_string:
                    if char == '{':
                        bracket_level += 1
                    elif char == '}':
                        bracket_level -= 1
                        if bracket_level == 0:
                            json_end = i
                            break

            if json_end > 0:
                json_str = content[start_idx:json_end + 1]

                # Проверяем если это валидный JSON и содержит структуру курса
                try:
                    parsed = json.loads(json_str)
                    # Проверяем, является ли это JSON-объектом курса (должен
                    # содержать lessons)
                    if isinstance(parsed, dict) and 'lessons' in parsed:
                        logger.info(f"Найдена структура курса в JSON объекте длиной {
        len(json_str)} символов")
                        return json_str
                    # Или если это массив уроков
                    elif isinstance(parsed, list) and len(parsed) > 0 and \
                         all(isinstance(item, dict) and 'title' in item for item in parsed):
                        logger.info(f"Найден массив уроков в JSON объекте длиной {
        len(json_str)} символов")
                        return json_str
                    else:
                        keys = list(
    parsed.keys()) if isinstance(
        parsed, dict) else "массив"
                        logger.debug(
    f"JSON объект не содержит структуру курса. Ключи: {keys}")
                except json.JSONDecodeError as e:
                    logger.debug(
    f"Извлеченный объект не является валидным JSON: {
        str(e)}")

        # Если не удалось найти валидный JSON курса, просто возвращаем исходный контент
        # Это позволит методу _parse_json_safely попытаться исправить JSON
        if content.strip().startswith('{') and content.strip().endswith('}'):
            logger.warning(
                "Не удалось найти структуру курса, но контент похож на JSON. Возвращаем исходный контент.")
            return content

        logger.warning("Структура курса не найдена в контенте")
        return ""

    async def _parse_json_safely(self, json_str: str) -> Dict[str, Any]:
        """
        Безопасно парсит JSON с исправлением распространенных ошибок

        Args:
            json_str: JSON-строка

        Returns:
            Dict[str, Any]: Словарь с данными или пустой словарь в случае ошибки
        """
        import json

        if not json_str or len(json_str.strip()) < 2:
            logger.error("Получена пустая или слишком короткая JSON-строка")
            return {}

        try:
            # Сначала пробуем стандартный парсинг
            logger.info(f"Попытка стандартного парсинга JSON длиной {
        len(json_str)} символов")
            # Логируем первые и последние символы для проверки
            start_chars = json_str[:50].replace('\n', '\\n')
            end_chars = json_str[-50:].replace('\n', '\\n')
            logger.info(f"Начало JSON: '{start_chars}...'")
            logger.info(f"Конец JSON: '...{end_chars}'")

            # Логируем символы в начале и конце (ASCII коды) для выявления
            # невидимых символов
            logger.info(f"ASCII коды первых 10 символов: {[ord(c) for c in json_str[:10]]}")
            logger.info(f"ASCII коды последних 10 символов: {[ord(c) for c in json_str[-10:]]}")

            parsed_json = json.loads(json_str)
            logger.info("Стандартный парсинг JSON успешен")
            # Кратко логируем структуру полученного JSON
            if isinstance(parsed_json, dict):
                logger.info(f"Структура JSON: объект с ключами {
        list(
            parsed_json.keys())}")
                if 'lessons' in parsed_json and isinstance(
                    parsed_json['lessons'], list):
                    logger.info(f"Найдено {len(parsed_json['lessons'])} уроков")
            elif isinstance(parsed_json, list):
                logger.info(f"Структура JSON: массив длиной {
        len(parsed_json)}")
            return parsed_json
        except json.JSONDecodeError as e:
            logger.error(
    f"Ошибка парсинга JSON (строка {
        e.lineno}, колонка {
            e.colno}): {
                str(e)}")
            logger.error("Контекст ошибки:")

            # Показываем контекст вокруг ошибки
            lines = json_str.split('\n')
            start_line = max(0, e.lineno - 3)
            end_line = min(len(lines), e.lineno + 2)
            context = '\n'.join(lines[start_line:end_line])
            logger.error(context)

            # Показываем фрагмент вокруг позиции ошибки
            pos = e.pos
            start_pos = max(0, pos - 20)
            end_pos = min(len(json_str), pos + 20)
            fragment = json_str[start_pos:end_pos].replace('\n', '\\n')
            logger.error(
    f"Фрагмент вокруг ошибки (позиция {pos}): '{fragment}'")

            # Пробуем исправить наиболее распространенные ошибки
            logger.info("Попытка исправления распространенных ошибок в JSON")
            fixed_json = self._fix_common_json_errors(json_str)

            try:
                # Пробуем парсить исправленный JSON
                logger.info("Попытка парсинга исправленного JSON")
                parsed_fixed_json = json.loads(fixed_json)
                logger.info("Исправленный JSON успешно спарсен")
                return parsed_fixed_json
            except json.JSONDecodeError as second_error:
                logger.error(
    f"Не удалось исправить JSON. Вторая ошибка: {
        str(second_error)}")
                # Логируем полную трассировку для отладки
                import traceback
                logger.error(
    f"Трассировка ошибки парсинга: {
        traceback.format_exc()}")

                # Пробуем более агрессивные методы исправления
                logger.info("Попытка более агрессивного исправления JSON")
                try:
                    # Удаляем все комментарии и проблемные символы
                    aggressive_fixed = re.sub(r'//.*?(?:\n|$)', '\n', json_str)
                    aggressive_fixed = re.sub(
    r'(?m)^\s*//.*$', '', aggressive_fixed)
                    aggressive_fixed = re.sub(
    r'/\*[\s\S]*?\*/', '', aggressive_fixed)

                    # Исправляем проблемы с запятыми
                    aggressive_fixed = re.sub(
    r',(\s*[\]}])', r'\1', aggressive_fixed)
                    aggressive_fixed = re.sub(
    r'([\[{]\s*),', r'\1', aggressive_fixed)

                    # Пробуем снова парсить
                    parsed_aggressive = json.loads(aggressive_fixed)
                    logger.info("JSON успешно исправлен агрессивным методом")
                    return parsed_aggressive
                except:
                    logger.error(
                        "Не удалось исправить JSON агрессивным методом")

                # Если все методы исправления не сработали, пробуем извлечь
                # хотя бы частичные данные
                logger.info(
                    "Попытка извлечения данных из некорректного JSON с помощью регулярных выражений")
                result = self._extract_data_from_malformed_json(json_str)

                # Проверяем, что мы смогли извлечь хоть какие-то данные
                if result and isinstance(result, dict) and (
                    'lessons' in result or 'name' in result):
                    lesson_count = len(
    result.get(
        'lessons',
         [])) if 'lessons' in result else 0
                    logger.info(f"Успешно создана базовая структура курса с {lesson_count} уроками из частичных данных")
                    return result

                # Если все методы не сработали, возвращаем пустой словарь
                logger.error("Не удалось извлечь данные из некорректного JSON")
                return {}

    def _extract_data_from_malformed_json(
        self, json_str: str) -> Dict[str, Any]:
        """
        Извлекает данные из некорректного JSON с помощью регулярных выражений

        Args:
            json_str: Некорректный JSON

        Returns:
            Dict[str, Any]: Словарь с извлеченными данными
        """
        # Базовая структура курса
        result = {
            "name": "Course generated from partial data",
            "description": "This course was automatically generated from partial data due to JSON parsing issues.",
            "language": "english",
            "level": "beginner",
            "lessons": []
        }

        # Пробуем извлечь имя курса
        name_match = re.search(r'"name"\s*:\s*"([^"]+)"', json_str)
        if name_match:
            result["name"] = name_match.group(1)

        # Пробуем извлечь описание курса
        desc_match = re.search(r'"description"\s*:\s*"([^"]+)"', json_str)
        if desc_match:
            result["description"] = desc_match.group(1)

        # Пробуем извлечь уровень
        level_match = re.search(r'"level"\s*:\s*"([^"]+)"', json_str)
        if level_match:
            result["level"] = level_match.group(1)

        # Пробуем извлечь язык
        lang_match = re.search(r'"language"\s*:\s*"([^"]+)"', json_str)
        if lang_match:
            result["language"] = lang_match.group(1)

        # Пробуем найти уроки - ищем структуры, похожие на уроки
        lesson_pattern = r'"title"\s*:\s*"([^"]+)".*?"objectives"\s*:\s*\[(.*?)\].*?"grammar"\s*:\s*\[(.*?)\].*?"vocabulary"\s*:\s*\[(.*?)\]'
        lesson_matches = re.finditer(lesson_pattern, json_str, re.DOTALL)

        for i, match in enumerate(lesson_matches, 1):
            title = match.group(1)

                    # Создаем базовую структуру урока
            lesson = {
                "title": title,
                "order": i,
                "objectives": self._extract_array_items(match.group(2)),
                "grammar": self._extract_array_items(match.group(3)),
                "vocabulary": self._extract_array_items(match.group(4)),
                "duration": 60,  # Значение по умолчанию - гарантированно положительное
                "activities": []
            }

            # Пробуем извлечь описание для этого урока
            lesson_desc_pattern = f'"title"\\s*:\\s*"{
    re.escape(title)}".*?"description"\\s*:\\s*"([^"]+)"'
            lesson_desc_match = re.search(
    lesson_desc_pattern, json_str, re.DOTALL)
            if lesson_desc_match:
                lesson["description"] = lesson_desc_match.group(1)
            else:
                # Если не нашли описание, добавляем стандартное
                logger.info(f"Добавлено недостающее поле 'description' для урока {i}")
                lesson["description"] = f"Lesson {i}: {title}"

            # Добавляем поле procedure если его нет
            if "procedure" not in lesson:
                logger.info(f"Добавлено недостающее поле 'procedure' для урока {i}")
                lesson["procedure"] = [
                    "Introduction to the topic",
                    "Grammar explanation",
                    "Vocabulary practice",
                    "Communication activities",
                    "Homework assignment"
                ]

            # Извлекаем homework
            homework_pattern = f'"title"\\s*:\\s*"{
    re.escape(title)}".*?"homework"\\s*:\\s*{{\\s*"description"\\s*:\\s*"([^"]+)",\\s*"tasks"\\s*:\\s*\\[(.*?)\\],\\s*"estimatedTime"\\s*:\\s*(\\d+)'
            homework_match = re.search(homework_pattern, json_str, re.DOTALL)
            if homework_match:
                estimated_time = int(homework_match.group(3))
                # Убедимся, что estimatedTime положительный
                if estimated_time <= 0:
                    estimated_time = 30  # Значение по умолчанию, если извлеченное значение некорректно

                lesson["homework"] = {
                    "description": homework_match.group(1),
                    "tasks": self._extract_array_items(homework_match.group(2)),
                    "estimatedTime": estimated_time
                }
            else:
                # Создаем стандартное домашнее задание
                lesson["homework"] = {
                    "description": f"Homework for lesson {i}",
                    "tasks": ["Review the material", "Complete exercises", "Prepare for the next lesson"],
                    "estimatedTime": 30
                }

            # Извлекаем duration если есть
            duration_pattern = f'"title"\\s*:\\s*"{
    re.escape(title)}".*?"duration"\\s*:\\s*(\\d+)'
            duration_match = re.search(duration_pattern, json_str, re.DOTALL)
            if duration_match:
                duration = int(duration_match.group(1))
                # Убедимся, что duration положительный
                if duration > 0:
                    lesson["duration"] = duration
                else:
                    logger.warning(
    f"Извлечена некорректная продолжительность урока: {duration}. Установлено значение по умолчанию: 60 минут")

            # Проверка и добавление материалов
            if "materials" not in lesson:
                logger.info(f"Добавлено недостающее поле 'materials' для урока {i}")
                lesson["materials"] = [
    "Textbook", "Workbook", "Audio recordings"]

            # Извлекаем activities если возможно
            activities_pattern = f'"title"\\s*:\\s*"{
    re.escape(title)}".*?"activities"\\s*:\\s*\\[(.*?)\\]'
            activities_match = re.search(
    activities_pattern, json_str, re.DOTALL)
            if activities_match:
                # Очень упрощенное извлечение активностей - только имя и тип
                activity_name_pattern = r'"name"\s*:\s*"([^"]+)".*?"type"\s*:\s*"([^"]+)"'
                activity_matches = re.finditer(
    activity_name_pattern, activities_match.group(1), re.DOTALL)

                for activity_match in activity_matches:
                    activity = {
                        "name": activity_match.group(1),
                        "type": activity_match.group(2),
                        "duration": 15,  # Значение по умолчанию
                        "description": f"Activity: {activity_match.group(1)}",
                        "materials": []
                    }
                    lesson["activities"].append(activity)

            # Если нет активностей, добавим одну базовую
            if not lesson["activities"]:
                lesson["activities"] = [{
                    "name": "Default activity",
                    "type": "practice",
                    "duration": 45,
                    "description": "General practice of the lesson material",
                    "materials": []
                }]

            # Добавляем урок в список уроков
            result["lessons"].append(lesson)

        if result["lessons"]:
            logger.info(f"Создан словарь с массивом в поле lessons, уроков: {len(result['lessons'])}")
        else:
            logger.warning("Не удалось извлечь ни одного урока из JSON")

            # Если не смогли извлечь уроки, создадим один базовый
            result["lessons"] = [{
                "title": "Lesson 1: Introduction",
                "order": 1,
                "description": "Introduction to the course material",
                "objectives": ["Learn basic concepts", "Develop initial skills", "Get familiar with materials"],
                "grammar": ["Basic grammar", "Simple structures"],
                "vocabulary": ["Essential vocabulary", "Common phrases"],
                "procedure": ["Introduction", "Main activity", "Practice", "Conclusion"],
                "materials": ["Textbook", "Workbook", "Audio recordings"],
                "homework": {
                    "description": "Practice basic skills",
                    "tasks": ["Review materials", "Complete exercises", "Prepare for next lesson"],
                    "estimatedTime": 30
                },
                "duration": 60,
                "activities": [{
                    "name": "Introduction to the topic",
                                "type": "presentation",
                    "duration": 20,
                    "description": "Presentation of the main concepts",
                    "materials": []
                }, {
                    "name": "Practice exercises",
                    "type": "practice",
                    "duration": 40,
                    "description": "Practical exercises to reinforce learning",
                    "materials": []
                }]
            }]
            logger.info(
                "Создан базовый урок, так как не удалось извлечь данные из JSON")

        return result

    def _extract_array_items(self, array_str: str) -> List[str]:
        """
        Извлекает элементы массива из строки JSON

        Args:
            array_str: Строка с элементами массива

        Returns:
            List[str]: Список извлеченных элементов
        """
        # Ищем все строки в кавычках
        items = re.findall(r'"([^"]*)"', array_str)
        return items if items else ["Item 1", "Item 2", "Item 3"]

    def _fix_common_json_errors(self, json_str: str) -> str:
        """
        Исправляет распространенные ошибки в JSON

        Args:
            json_str: Исходная JSON-строка

        Returns:
            str: Исправленная JSON-строка
        """
        # Заменяем одинарные кавычки на двойные
        json_str = re.sub(r"(?<![\\])\'", '"', json_str)

        # Убираем запятые перед закрывающими скобками массивов и объектов
        json_str = re.sub(r',\s*}', '}', json_str)
        json_str = re.sub(r',\s*\]', ']', json_str)

        # Добавляем кавычки к незаключенным в кавычки ключам
        json_str = re.sub(
    r'([{,])\s*([a-zA-Z0-9_]+)\s*:',
    r'\1"\2":',
     json_str)

        # Исправляем незакрытые строки
        lines = json_str.split('\n')
        fixed_lines = []

        quote_count = 0  # Отслеживаем общее количество кавычек
        in_string = False  # Флаг, находимся ли мы внутри строки
        bracket_count = 0  # Отслеживаем уровень вложенности скобок
        in_escape = False  # Флаг, был ли предыдущий символ экранирующим

        for i, line in enumerate(lines):
            # Проверяем наличие некорректных символов (контрольные символы)
            line = re.sub(r'[\x00-\x09\x0B\x0C\x0E-\x1F\x7F]', '', line)

            # Обрабатываем кавычки и экранирование в строке
            clean_line = ""
            for j, char in enumerate(line):
                if char == '\\' and not in_escape:
                    in_escape = True
                    clean_line += char
                    continue

                if char == '"' and not in_escape:
                    quote_count += 1
                    in_string = not in_string
                elif char == '{' and not in_string:
                    bracket_count += 1
                elif char == '}' and not in_string:
                    bracket_count -= 1
                elif char == '[' and not in_string:
                    bracket_count += 1
                elif char == ']' and not in_string:
                    bracket_count -= 1

                in_escape = False
                clean_line += char

            # Если в этой строке нечетное количество кавычек, добавляем
            # закрывающую кавычку
            if quote_count % 2 == 1 and in_string and i < len(lines) - 1:
                clean_line += '"'
                in_string = False
                quote_count += 1

            fixed_lines.append(clean_line)

        # Убедимся, что все кавычки закрыты
        result = '\n'.join(fixed_lines)

        # Исправляем некорректные значения JSON
        # Заменяем случайные слова, которые могут быть без кавычек, но не
        # являются JSON-значениями
        result = re.sub(
    r':\s+([\w\s]+)(?=,|})',
    lambda m: ': "' + m.group(1) + '"',
     result)

        # Заменяем обрезанные или неполные значения в конце строк
        result = re.sub(r':\s*$', ': ""', result)

        # Заменяем множественные запятые
        result = re.sub(r',\s*,', ',', result)

        # Исправляем пропущенные значения (ключ без значения)
        result = re.sub(r'"([^"]+)":\s*(?=,|})', r'"\1": null', result)

        # Исправляем экранированные кавычки внутри строк
        result = re.sub(r'(?<!\\)\\(?!["\\])', r'\\\\', result)

        # Проверяем и исправляем незакрытую структуру
        if bracket_count > 0:
            # Недостаточно закрывающих скобок
            result += '}' * bracket_count
        elif bracket_count < 0:
            # Недостаточно открывающих скобок (удаляем лишние закрывающие)
            excess = abs(bracket_count)
            last_index = len(result) - 1
            while excess > 0 and last_index >= 0:
                if result[last_index] == '}':
                    result = result[:last_index] + result[last_index + 1:]
                    excess -= 1
                last_index -= 1

        logger.info(f"Исправлено ошибок JSON. Результат длиной {
        len(result)} символов")
        return result

    def _generate_fallback_structure(
        self, prompt: Dict[str, Any]) -> Dict[str, Any]:
        """
        Генерирует базовую структуру курса в случае ошибок

        Args:
            prompt: Промпт для генерации

        Returns:
            Dict[str, Any]: Запасная структура курса
        """
        context = prompt.get('context', {})
        course_name = context.get('course_name', 'Новый курс')
        language = context.get('language', 'english')
        level = context.get('level', 'beginner')
        target_level = context.get('level', 'beginner')
        start_level = context.get('start_level', level)
        target_audience = context.get('target_audience', 'adults')
        lessons_count = int(context.get('lessons_count', 12))

        logger.info(f"Создание запасной структуры курса с {lessons_count} уроками")

        # Базовые темы для уроков начального уровня
        beginner_topics = [
            "Знакомство и приветствия",
            "Семья и родственники",
            "Числа и счет",
            "Время и даты",
            "Еда и рестораны",
            "Дом и мебель",
            "Город и ориентирование на местности",
            "Покупки и магазины",
            "Погода и времена года",
            "Хобби и свободное время",
            "Путешествия и транспорт",
            "Здоровье и тело человека"
        ]

        # Базовые темы для среднего уровня
        intermediate_topics = [
            "Образование и карьера",
            "Технологии и интернет",
            "Искусство и культура",
            "Окружающая среда и экология",
            "Новости и СМИ",
            "Личные отношения",
            "Социальные вопросы",
            "Спорт и физическая активность",
            "Празднования и обычаи",
            "Наука и исследования",
            "Бизнес и экономика",
            "Проблемы современного общества"
        ]

        # Базовые темы для продвинутого уровня
        advanced_topics = [
            "Глобальные проблемы человечества",
            "Философия и этика",
            "Литература и критическое мышление",
            "Международные отношения",
            "Психология и поведение человека",
            "Дебаты и аргументация",
            "Современное искусство",
            "Научные достижения",
            "Межкультурная коммуникация",
            "История и цивилизации",
            "Финансы и инвестиции",
            "Профессиональное развитие"
        ]

        # Выбираем темы в зависимости от уровня
        if level.lower() in ['advanced', 'c1', 'c2', 'proficiency']:
            topics = advanced_topics
        elif level.lower() in ['intermediate', 'b1', 'b2']:
            topics = intermediate_topics
            else:
            topics = beginner_topics

        # Обеспечиваем достаточное количество тем для уроков
        while len(topics) < lessons_count:
            topics += topics

        lessons = []
        for i in range(lessons_count):
            # Формируем название и номер урока с учетом темы
            topic = topics[i % len(topics)]
            title = f"Урок {i + 1}: {topic}"

            # Базовые цели обучения, связанные с темой
            objectives = [
                f"Изучить новую лексику по теме \"{topic}\"",
                f"Освоить грамматические конструкции уровня {level}",
                f"Развить навыки говорения по теме \"{topic}\"",
                f"Улучшить навыки аудирования в контексте \"{topic.lower()}\""
            ]

            # Создаем описание урока - это обязательное поле!
            description = f"Урок {
    i +
     1} посвящен теме \"{topic}\". Студенты изучат новую лексику, грамматические конструкции и разовьют коммуникативные навыки в контексте данной темы. Урок включает разнообразные активности для тренировки всех языковых навыков: чтения, письма, говорения и аудирования."

            # Генерируем типичные активности для урока
            activities = [
                {
                    "name": "Разминка",
                    "type": "warm-up",
                    "duration": 10,
                    "description": f"Короткое обсуждение предыдущих знаний по теме \"{topic}\"",
                    "materials": ["Карточки с вопросами", "Доска"]
                },
                {
                    "name": "Введение новой лексики",
                    "type": "vocabulary",
                    "duration": 15,
                    "description": f"Презентация и отработка новых слов и выражений по теме \"{topic}\"",
                    "materials": ["Картинки", "Презентация", "Раздаточный материал"]
                },
                {
                    "name": "Грамматическая практика",
                    "type": "grammar",
                    "duration": 15,
                    "description": "Объяснение грамматического материала и выполнение упражнений",
                    "materials": ["Учебник", "Грамматические таблицы", "Рабочая тетрадь"]
                },
                {
                    "name": "Разговорная практика",
                    "type": "speaking",
                    "duration": 15,
                    "description": f"Выполнение коммуникативных заданий по теме \"{topic}\"",
                    "materials": ["Ситуационные карточки", "Ролевые карточки"]
                },
                {
                    "name": "Заключение",
                    "type": "summary",
                    "duration": 5,
                    "description": "Подведение итогов урока и объяснение домашнего задания",
                    "materials": ["Доска", "Раздаточный материал с домашним заданием"]
                }
            ]

            # Формируем домашнее задание как список задач
            homework_tasks = [
                f"Выполнить упражнения в рабочей тетради (стр. {(i + 1) * 2}-{(i + 1) * 2 + 2})",
                f"Выучить новые слова по теме \"{topic}\"",
                f"Подготовить монолог/диалог на тему \"{topic}\""
            ]

            # Преобразуем в формат словаря, соответствующий схеме
            homework = {
                "description": f"Домашнее задание для закрепления темы \"{topic}\"",
                "tasks": homework_tasks,
                "estimatedTime": 30
            }

            # Формируем список грамматических тем в зависимости от уровня
            if level.lower() in ['beginner', 'a1', 'a2', 'elementary']:
                grammar = [
                    "Личные и притяжательные местоимения",
                    "Простое настоящее время (Present Simple)",
                    "Настоящее продолженное время (Present Continuous)",
                    "Модальные глаголы can/could"
                ]
            elif level.lower() in ['intermediate', 'b1', 'b2']:
                grammar = [
                    "Прошедшие времена (Past Simple, Past Continuous, Past Perfect)",
                    "Условные предложения (Conditionals) I и II типа",
                    "Страдательный залог (Passive Voice)",
                    "Косвенная речь (Reported Speech)"
                ]
            else:
                grammar = [
                    "Сложные временные формы",
                    "Условные предложения смешанного типа",
                    "Инверсия и эмфатические конструкции",
                    "Сложные предложные и фразовые обороты"
                ]

            # Формируем список словарного запаса в зависимости от темы урока
            vocabulary = [
    f"{topic}: базовая лексика",
    f"{topic}: идиомы и выражения",
     f"{topic}: ситуативная лексика"]

            # Формируем базовый урок
            lesson = {
                "title": title,
                "description": description,
                "objectives": objectives,
                "grammar": grammar,
                "vocabulary": vocabulary,
                "procedure": [
                    "Вводная часть (5-10 минут): приветствие, проверка домашнего задания, знакомство с темой урока",
                    "Презентация нового материала (15 минут): объяснение новой лексики и грамматики",
                    "Практика понимания (10 минут): упражнения на понимание и применение нового материала",
                    "Коммуникативная практика (15 минут): диалоги, ролевые игры, дискуссии",
                    "Заключение (5-10 минут): обзор изученного материала, объяснение домашнего задания"
                ],
                "activities": activities,
                "materials": ["Учебник", "Рабочая тетрадь", "Аудиоматериалы", "Презентация", "Раздаточный материал"],
                "homework": homework,
                "duration": 60,  # Устанавливаем положительное значение продолжительности
                "order": i + 1
            }

            lessons.append(lesson)

        # Формируем структуру курса
        course_description = f"Курс изучения {language} языка для перехода с уровня {start_level} на уровень {target_level}. Курс разработан для {target_audience} и включает {lessons_count} интерактивных уроков с широким набором коммуникативных упражнений и заданий для развития всех языковых навыков."

        course_structure = {
            "name": course_name,
            "description": course_description,
            "language": language,
            "level": level,
            "start_level": start_level,
            "target_audience": target_audience,
            "lessons": lessons,
            "prerequisites": ["Базовые знания языка (если требуются)", "Доступ к учебным материалам"],
            "learning_outcomes": [
                "Развитие навыков устной речи",
                "Расширение словарного запаса",
                "Улучшение понимания грамматики",
                "Повышение уровня владения языком"
            ]
        }

        logger.info(f"Создана запасная структура курса с {
        len(lessons)} уроками")
        return course_structure

    def _generate_default_value(
        self, field: str, prompt: Dict[str, Any]) -> Any:
        """
        Генерирует значение по умолчанию для заданного поля

        Args:
            field: Имя поля
            prompt: Исходный промпт

        Returns:
            Any: Значение по умолчанию
        """
        context = prompt['context']

        if field == 'name':
            return context['course_name']
        elif field == 'description':
            return "Курс изучения {0} языка для {1} {2} уровня".format(
                context['language'],
                context['target_audience'],
                context['level']
            )
        elif field == 'lessons':
            return self._generate_default_lessons(prompt)
        elif field in ['prerequisites', 'learning_outcomes']:
            return []

        return ""

    def _generate_default_lessons(
        self, prompt: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Генерирует базовый набор уроков

        Args:
            prompt: Исходный промпт

        Returns:
            List[Dict[str, Any]]: Список уроков
        """
        context = prompt['context']
        lessons_count = min(
    context.get(
        'lessons_count',
        10),
         20)  # Не более 20 уроков
        lesson_duration = context.get('lesson_duration', 60)

        lessons = []

        for i in range(1, lessons_count + 1):
            lesson = {
                "title": "Урок {0}".format(i),
                "objectives": ["Изучение новой темы"],
                "grammar": [],
                "vocabulary": [],
                "duration": lesson_duration,
                "procedure": [
                    "Вводная часть (10 минут): знакомство с темой урока",
                    "Презентация нового материала (15 минут): объяснение ключевых понятий",
                    "Практика (20 минут): упражнения для закрепления",
                    "Разговорная практика (10 минут): применение изученного в общении",
                    "Заключение (5 минут): обзор изученного материала"
                ],
                "activities": [
                    {
                        "name": "Введение в тему",
                        "type": "warm-up",
                        "duration": 10,
                        "description": "Вводное упражнение для ознакомления с темой урока",
                        "materials": [],
                        "objectives": []
                    },
                    {
                        "name": "Основная часть",
                        "type": "practice",
                        "duration": lesson_duration - 20,
                        "description": "Основные упражнения урока",
                        "materials": [],
                        "objectives": []
                    },
                    {
                        "name": "Закрепление",
                        "type": "production",
                        "duration": 10,
                        "description": "Закрепление изученного материала",
                        "materials": [],
                        "objectives": []
                    }
                ],
                "materials": [],
                "homework": {
                    "description": "Домашнее задание для закрепления материала урока {0}".format(i),
                    "tasks": ["Повторение изученного материала", "Выполнение практических заданий"],
                    "estimatedTime": 30
                }
            }
            lessons.append(lesson)

        return lessons

    def _create_cache_key(self,
    prompt: str,
    content_type: ContentType,
    extra_params: Optional[Dict[str,
     Any]] = None) -> str:
        """
        Создает уникальный ключ для кэширования на основе промпта и параметров

        Args:
            prompt: Текст промпта
            content_type: Тип контента
            extra_params: Дополнительные параметры для генерации

        Returns:
            str: Ключ для кэширования
        """
        # Создаем хэш промпта
        prompt_hash = hashlib.md5(prompt.encode()).hexdigest()

        # Если есть дополнительные параметры, добавляем их хэш
        params_hash = ""
        if extra_params:
            # Преобразуем в отсортированный JSON для стабильного хэширования
            try:
                params_str = json.dumps(
    extra_params, sort_keys=True, default=str)
                params_hash = ":{0}".format(hashlib.md5(
                    params_str.encode()).hexdigest()[:8])
            except:
                # Если не удалось сериализовать параметры, игнорируем их
                pass

        # Формируем итоговый ключ
        content_type_str = content_type.value if hasattr(
            content_type, 'value') else str(content_type)
        return "content:{0}:{1}{2}".format(
    content_type_str, prompt_hash, params_hash)

    async def _fix_json_with_llm(self, problematic_json: str) -> str:
        """
        Использовать LLM для исправления проблемного JSON

        Args:
            problematic_json: Проблемный JSON, который не удалось распарсить стандартными методами

        Returns:
            str: Исправленный JSON или пустая строка, если не удалось исправить
        """
        try:
            logger.info("Попытка исправления JSON с помощью LLM")

            # Формируем промпт для LLM
            prompt = """
            У меня есть неправильно отформатированный JSON, который не удается распарсить.
            Пожалуйста, исправь все проблемы и верни только корректно отформатированный JSON без дополнительных пояснений.

            Проблемный JSON:
            ```
            {0}
            ```

            Исправленный JSON (только JSON, без пояснений):
            """

            # Применяем форматирование
            prompt = prompt.format(problematic_json)

            # Отправляем промпт с инструкцией возвращать только JSON
            content = await self.generate_content(
                user_id=0,  # Системная генерация
                prompt=prompt,
                content_type=ContentType.STRUCTURED_DATA,
                force_queue=False,  # Требуется быстрый ответ
                extra_params={
    "format": "json",
    "task": "fix_json",
     "max_tokens": 4000}
            )

            if not content:
                logger.error(
                    "LLM вернула пустой результат при исправлении JSON")
                return ""

            # Очищаем результат от лишних блоков форматирования и получаем JSON
            content = self._clean_json_response(content)
            json_str = self._extract_json_from_content(content)

            if not json_str:
                logger.error(
                    "Не удалось извлечь исправленный JSON из ответа LLM")
                return ""

            # Проверяем, что получился валидный JSON
            try:
                json.loads(json_str)
                logger.info("LLM успешно исправила JSON")
                return json_str
            except json.JSONDecodeError as e:
                logger.error(
    f"LLM не смогла полностью исправить JSON: {
        str(e)}")
                return ""

        except Exception as e:
            logger.error(
    f"Ошибка при попытке исправить JSON с помощью LLM: {
        str(e)}")
            return ""

    def _enrich_lesson_data(self, lesson: dict, index: int) -> dict:
        """
        Обогащает данные урока недостающими полями.

        Args:
            lesson: Исходные данные урока
            index: Номер урока

        Returns:
            Обогащенный словарь урока с обязательными полями
        """
        # Создаем копию для изменения
        enriched = lesson.copy()

        # Обязательные поля для урока
        required_fields = {
            "title": "Урок {0}".format(index),
            "description": "Описание урока {0}".format(index),
            "objectives": [],
            "materials": [],
            "vocabulary": [],
            "grammar": [],
            "procedure": [],
            "homework": {
                "description": "Домашнее задание для урока {0}".format(index),
                "tasks": ["Выполнить упражнения по теме урока"],
                "estimatedTime": 30
            }
        }

        # Заполняем недостающие поля
        for field, default_value in required_fields.items():
            if field not in enriched or not enriched[field]:
                enriched[field] = default_value
                logger.info(
    "Добавлено недостающее поле '{0}' для урока {1}".format(
        field, index))

        # Если есть поля типа procedure, objectives и т.д., но они строки,
        # преобразуем их в списки
        fields_to_check = [
    "objectives",
    "materials",
    "vocabulary",
    "grammar",
     "procedure"]
        for field in fields_to_check:
            if field in enriched and isinstance(enriched[field], str):
                # Пытаемся разделить строку на абзацы или пункты
                parts = [part.strip()
                                    for part in enriched[field].split('\n') if part.strip()]
                if not parts:  # Если после разделения список пустой
                    # Используем всю строку как один элемент
                    parts = [enriched[field]]
                enriched[field] = parts
                logger.info(
    "Преобразовано поле '{0}' из строки в список для урока {1}".format(
        field, index))

        # КРИТИЧЕСКИ ВАЖНОЕ ИСПРАВЛЕНИЕ: гарантируем, что homework всегда будет
        # словарем в соответствии со схемой
        if "homework" in enriched:
            # Если homework не является словарем, преобразуем его
            if not isinstance(enriched["homework"], dict):
                # Сохраняем оригинальные задания
                original_homework = enriched["homework"]

                # Создаем правильную структуру словаря
                homework_dict = {
                    "description": f"Домашнее задание для урока {index}",
                    "tasks": [],
                    "estimatedTime": 30
                }

                # Преобразуем исходное значение в список задач
                if isinstance(original_homework, list):
                    # Если это уже список, используем его как tasks
                    homework_dict["tasks"] = [
    str(item) for item in original_homework]
                elif isinstance(original_homework, str):
                    # Если это строка, разбиваем ее на отдельные задания
                    items = [
    item.strip() for item in original_homework.split('\n') if item.strip()]
                    homework_dict["tasks"] = items if items else [
                        original_homework]
                    else:
                    # Если что-то совсем непонятное, создаем задание по
                    # умолчанию
                    homework_dict["tasks"] = [
                        "Выполнить упражнения по теме урока"]

                enriched["homework"] = homework_dict
                logger.info(f"Преобразовано поле \'homework\' в правильный формат словаря для урока {index}")
            else:
                # Проверяем наличие необходимых полей в уже существующем
                # словаре homework
                if "description" not in enriched["homework"] or not enriched["homework"]["description"]:
                    enriched["homework"]["description"] = f"Домашнее задание для урока {index}"
                if "tasks" not in enriched["homework"] or not enriched["homework"]["tasks"]:
                    enriched["homework"]["tasks"] = [
                        "Выполнить упражнения по теме урока"]

                # Гарантируем, что tasks - это массив
                if not isinstance(enriched["homework"]["tasks"], list):
                    if isinstance(enriched["homework"]["tasks"], str):
                        enriched["homework"]["tasks"] = [
                            enriched["homework"]["tasks"]]
                        else:
                        enriched["homework"]["tasks"] = [
                            str(enriched["homework"]["tasks"])]


                # Гарантируем, что estimatedTime существует и положительный
                if "estimatedTime" not in enriched["homework"] or not isinstance(enriched["homework"]["estimatedTime"], (int, float)) or enriched["homework"]["estimatedTime"] <= 0:
                    enriched["homework"]["estimatedTime"] = 30
        
        # Добавляем поле 'order' если его нет
        if 'order' not in enriched:
            enriched['order'] = index
            
        # Проверяем, что duration > 0
        if 'duration' not in enriched or not enriched['duration'] or enriched['duration'] <= 0:
            enriched['duration'] = 60  # Значение по умолчанию - 60 минут
            logger.info("Установлено положительное значение продолжительности для урока {0}".format(index))
            
        return enriched